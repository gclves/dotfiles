#+TITLE: GNU Emacs configuration
#+STARTUP: indent
#+LAYOUT: post
#+OPTIONS: H:5 num:nil tags:nil toc:nil timestamps:t
#+DESCRIPTION: Loading Emacs configuration using org-babel
#+TAGS: emacs

* Who am I
#+BEGIN_SRC emacs-lisp
  (setq user-full-name "Guilherme Goncalves"
        user-email-address "gsg@ggoncalves.me")
#+END_SRC
* Window setup
I like to set the appearance as early as possible to avoid glitches in
the loading process. This makes for a cleaner Emacs window.

#+BEGIN_SRC emacs-lisp
  (if (fboundp 'tool-bar-mode) (tool-bar-mode -1))
  (if (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
  (global-hl-line-mode t)
  (fringe-mode 1) ; 1px fringe
  (column-number-mode)
  (blink-cursor-mode)
  (tooltip-mode -1)
  (setq inhibit-startup-message t
        initial-scratch-message ""
        mode-line-default-help-echo nil
        indicate-buffer-boundaries nil
        indicate-empty-lines nil
        cursor-in-non-selected-windows nil
        highlight-nonselected-windows nil
        bidi-display-reordering nil
        blink-matching-paren nil)
#+END_SRC

This config file is used across multiple computers and different OSes, which
render fonts quite differently. This might be overkill, but I want to have a
list of options of fonts to render so we don't end up with garbage.

#+BEGIN_SRC emacs-lisp
  (let ((font-list '(("Fantasque Sans Mono" . 16) ("Inconsolata" . 16)))
        (supported-fonts (font-family-list))
        (format-font-name (lambda (font)
                            (destructuring-bind (font-name . font-size) font
                              (concat font-name "-" (number-to-string font-size))))))
    (some (lambda (font) (when (member (car font) supported-fonts)
                      (set-default-font (funcall format-font-name font))
                      t))
          font-list))
#+END_SRC

* Package setup
#+BEGIN_SRC emacs-lisp
    (require 'package)
    (setq package-archives '(("gnu" . "https://elpa.gnu.org/packages/")
                             ("org" . "http://orgmode.org/elpa/")
                             ("marmalade" . "https://marmalade-repo.org/packages/")
                             ("melpa" . "https://melpa.org/packages/")))
  (package-initialize)

  (unless package-archive-contents
    (package-refresh-contents))

  (unless (package-installed-p 'use-package)
    (package-initialize)
    (package-install 'use-package))

  (setq use-package-always-ensure t)

#+END_SRC

* Look and feel
** Other customizations
This replaces some words with their Math symbols (eg: lambda => Î»).
#+BEGIN_SRC emacs-lisp
  (global-prettify-symbols-mode 1)
#+END_SRC

Prettier Unicode symbols.
#+BEGIN_SRC emacs-lisp
  (when (member "Symbola" (font-family-list))
    (set-fontset-font t 'unicode "Symbola" nil 'prepend))
#+END_SRC

Highlight changes in the gutter
#+BEGIN_SRC emacs-lisp
  (use-package git-gutter
    :diminish git-gutter-mode
    :init (global-git-gutter-mode +1)
    :config
    (setq git-gutter:update-interval 2)
    (mapc (lambda (pair)
            (set-face-background (car pair) (cdr pair))
            (set-face-foreground (car pair) (cdr pair)))
          '((git-gutter:added . "#8bc34a")
            (git-gutter:modified . "#b39ddb")
            (git-gutter:deleted . "#f36c60")))
    :bind
    (("C-c C-n" . git-gutter:next-hunk)
     ("C-c C-p" . git-gutter:previous-hunk)))
#+END_SRC

Show time and status information on the modeline, so we can go fullscreen and
don't depend on the OS.
#+BEGIN_SRC emacs-lisp
  (setq display-time-default-load-average 0) ; 1-minute load average
  (display-time-mode)
  (display-battery-mode)
#+END_SRC
*** Highlight TODO entries
#+BEGIN_SRC emacs-lisp
  (use-package hl-todo
    :init (global-hl-todo-mode)
    :bind
    (:map hl-todo-mode-map
          ("C-c <up>" . hl-todo-previous)
          ("C-c <down>" . hl-todo-next)
          ("C-c T" . hl-todo-occur)))
#+END_SRC
*** Miscellaneous
#+BEGIN_SRC emacs-lisp
  ;;; Display rules at column 80
  (setq-default fill-column 80)
  (use-package fill-column-indicator
    :config
    (add-hook 'prog-mode-hook 'fci-mode))
#+END_SRC

* Editing goodies
** Ain't nobody got time for typing "yes"/"no".
#+BEGIN_SRC emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC
** Interactively do things
#+BEGIN_SRC emacs-lisp
  (use-package ivy
    :bind
    (:map global-map
          ("s-f" . swiper)
          ("s-b" . ivy-switch-buffer)
          ("s-g" . ivy-resume)
          ("M-x" . counsel-M-x)
          ("C-x C-f" . counsel-find-file)
          ("s-o" . counsel-find-file)
          ("<f6> f" . counsel-describe-function)
          ("<f6> v" . counsel-describe-variable)
          ("<f6> l" . counsel-find-library)
          ("<f6> i" . counsel-info-lookup-symbol)
          ("<f6> u" . counsel-unicode-char)
          ("C-c g" . counsel-git)
          ("C-c G" . counsel-git-grep)
          ("M-S-f" . counsel-ag)
          ("C-x l" . counsel-locate)
          ("C-c i" . counsel-imenu)
          ("s-i" . counsel-imenu)
          :map minibuffer-local-map
          ("C-r" . counsel-minibuffer-history))
    :config
    (progn
      (setq ivy-use-virtual-buffers 1
            ivy-use-selectable-prompts 0
            enable-recursive-minibuffers 1))
    :init (ivy-mode))

  (use-package projectile
    :bind
    (("s-&" . projectile-run-async-shell-command-in-root)
     ("s-!" . projectile-run-eshell)
     ("C-!" . projectile-run-shell-command-in-root)
     ("C-c C-e" . projectile-run-eshell)
     ("C-c C-s" . projectile-run-shell)
     ("C-\\" . projectile-find-file)
     ("s-p" . projectile-find-file)
     ("M-F" . projectile-ag))
    :init (projectile-mode)
    :config
    (progn
      (setq projectile-completion-system 'ivy)

      (defun run-grunt ()
        "Runs the command \"grunt fwatch\" on the projectile
        root. Splits the current window and display the output in
        a new buffer named *grunt*. In the *grunt* buffer, C-c C-c
        kills the process and closes the window."
        (interactive)
        (let ((buffer (get-buffer-create "*grunt*"))
              (height (/ (window-total-height) 3)))
          (split-window-below (- height))
          (other-window 1)
          (switch-to-buffer buffer)
          (comint-mode)
          (local-set-key (kbd "C-c C-c") (lambda ()
                                           (interactive)
                                           (comint-kill-subjob)
                                           (kill-buffer-and-window)))
          (cd (projectile-project-root))
          (start-process "grunt" buffer "grunt" "fwatch" "--no-color")
          (other-window -1)))
      (define-key projectile-mode-map (kbd "<f5>") 'run-grunt)))

  (use-package counsel-projectile
    :bind ("C-S-f" . counsel-projectile-ag))
#+END_SRC

** Moving around
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-S-w") (lambda () (interactive) (kill-buffer nil)))
  (global-set-key (kbd "C-b") 'ido-switch-buffer)
  (global-set-key (kbd "M-o") 'next-multiframe-window)
  (global-set-key (kbd "M-O") 'previous-multiframe-window)

  (global-set-key (kbd "M-3") 'delete-other-windows)
  (global-set-key (kbd "M-4") 'split-window-below)
  (global-set-key (kbd "M-$") 'split-window-right)
  (global-set-key (kbd "M-9") 'delete-window)

  (windmove-default-keybindings 'super)
  (setq windmove-wrap-around t)

  ; no more janky scrolling
  (setq scroll-conservatively 100)

  (use-package undo-tree
    :diminish undo-tree-mode
    :bind
    (("C-z" . undo-tree-undo)
     ("C-S-z" . undo-tree-redo)
     ("s-z" . undo-tree-undo)
     ("s-S-z" . undo-tree-redo)
     ("s-Z" . undo-tree-redo)
     ("C-x u" . undo-tree-visualize)
     ("<S-mouse-4>" . undo-tree-undo)
     ("<S-mouse-5>" . undo-tree-redo))
    :config
    (global-undo-tree-mode))

  (use-package zoom-window
    :bind
    (("M-1" . zoom-window-zoom)))

  (defun jump-to-scratch ()
    (interactive)
    (switch-to-buffer "*scratch*"))
  (global-set-key (kbd "M--") 'jump-to-scratch)

  (defun back-to-indentation-or-beginning ()
    "Move point to beginning of line, or to first non-space character"
    (interactive)
    (if (= (point) (progn (back-to-indentation) (point)))
        (beginning-of-line)))
  (global-set-key (kbd "<home>") 'back-to-indentation-or-beginning)
  (global-set-key (kbd "C-a") 'back-to-indentation-or-beginning)

  (defun goto-line-with-feedback ()
    "Show line numbers temporarily, while prompting for the line number input"
    (interactive)
    (unwind-protect
        (progn
          (linum-mode 1)
          (goto-line (read-number "Goto line: ")))
      (linum-mode -1)))
  (global-set-key [remap goto-line] 'goto-line-with-feedback)
#+END_SRC

** Get rid of useless whitespace
#+BEGIN_SRC emacs-lisp
  (use-package ws-butler
    :config (ws-butler-global-mode)
    :diminish ws-butler-mode)

  (defun cleanup-buffer-safe ()
    "Perform a bunch of safe operations on the whitespace content.
  For a more agressive cleanup that also does indentation, use
  cleanup-buffer."
    (interactive)
    (untabify (point-min) (point-max))
    (set-buffer-file-coding-system 'utf-8))

  (defun cleanup-buffer ()
    "Perform a bunch of operations on the whitespace content of a buffer.
  Including indent-buffer, which should not be called automatically on save."
    (interactive)
    (whitespace-cleanup)
    (cleanup-buffer-safe)
    (indent-region (point-min) (point-max)))

  (global-set-key (kbd "C-c N") 'cleanup-buffer)
  (global-set-key (kbd "C-c n") 'cleanup-buffer-safe)

  (global-set-key (kbd "RET") 'newline-and-indent)

  (setq fill-column 80)
  (setq-default indent-tabs-mode nil)

  ;; Render all whitespace: useful, but crowded
  ;; (setq whitespace-style '(face trailing tabs newline tab-mark space-mark))
  (setq whitespace-style '(face trailing tabs newline))
  (setq whitespace-display-mappings
        '((tab-mark 9 [8594 9])
          (space-mark 32 [183] [46])
          (space-mark 160 [164])
          (newline-mark 10 [8617 10])))

  (add-hook 'prog-mode-hook 'whitespace-mode)
#+END_SRC

** Copy-paste goodness stolen from Xah Lee
#+BEGIN_SRC emacs-lisp
  (defun xah-cut-line-or-region ()
    "Cut current line, or text selection.
  When `universal-argument' is called first, cut whole buffer (respects `narrow-to-region')."
    (interactive)
    (if current-prefix-arg
        (progn ; not using kill-region because we don't want to include previous kill
          (kill-new (buffer-string))
          (delete-region (point-min) (point-max)))
      (progn (if (use-region-p)
                 (kill-region (region-beginning) (region-end) t)
               (kill-whole-line)))))

  (defun xah-copy-line-or-region ()
    "Copy current line, or text selection.
  When called repeatedly, append copy subsequent lines.
  When `universal-argument' is called first, copy whole buffer (respects `narrow-to-region')."
    (interactive)
    (let (-p1 -p2)
      (if current-prefix-arg
          (setq -p1 (point-min) -p2 (point-max))
        (if (use-region-p)
            (setq -p1 (region-beginning) -p2 (region-end))
          (setq -p1 (line-beginning-position) -p2 (line-end-position))))
      (if (eq last-command this-command)
          (progn
            (progn ; hack. exit if there's no more next line
              (end-of-line)
              (forward-char)
              (backward-char))
            (push-mark (point) "NOMSG" "ACTIVATE")
            (kill-append "\n" nil)
            (kill-append (buffer-substring-no-properties (line-beginning-position) (line-end-position)) nil)
            (message "Line copy appended"))
        (progn
          (kill-ring-save -p1 -p2)
          (if current-prefix-arg
              (message "Buffer text copied")
            (message "Text copied"))))
      (end-of-line)
      (forward-char)))

  (global-set-key (kbd "C-w") 'xah-cut-line-or-region)
  (global-set-key (kbd "s-x") 'xah-cut-line-or-region)
  (global-set-key (kbd "M-w") 'xah-copy-line-or-region)
  (global-set-key (kbd "s-c") 'xah-copy-line-or-region)
#+END_SRC

** Manipulate a file directly from its buffer
#+BEGIN_SRC emacs-lisp
  (defun delete-current-buffer-file ()
    "Removes file connected to current buffer and kills buffer."
    (interactive)
    (let ((filename (buffer-file-name))
          (buffer (current-buffer))
          (name (buffer-name)))
      (if (not (and filename (file-exists-p filename)))
          (ido-kill-buffer)
        (when (yes-or-no-p "Are you sure you want to remove this file? ")
          (delete-file filename)
          (kill-buffer buffer)
          (message "File '%s' successfully removed" filename)))))
  (global-set-key (kbd "C-x C-k") 'delete-current-buffer-file)

  (defun rename-current-buffer-file ()
    "Renames current buffer and file it is visiting."
    (interactive)
    (let ((name (buffer-name))
          (filename (buffer-file-name)))
      (if (not (and filename (file-exists-p filename)))
          (error "Buffer '%s' is not visiting a file!" name)
        (let ((new-name (read-file-name "New name: " filename)))
          (if (get-buffer new-name)
              (error "A buffer named '%s' already exists!" new-name)
            (rename-file filename new-name 1)
            (rename-buffer new-name)
            (set-visited-file-name new-name)
            (set-buffer-modified-p nil)
            (message "File '%s' successfully renamed to '%s'"
                     name (file-name-nondirectory new-name)))))))
  (global-set-key (kbd "C-x C-r") 'rename-current-buffer-file)

#+END_SRC

** Open line
#+BEGIN_SRC emacs-lisp
  (defun open-line-below ()
    (interactive)
    (end-of-line)
    (newline)
    (indent-for-tab-command))

  (defun open-line-above ()
    (interactive)
    (beginning-of-line)
    (newline)
    (forward-line -1)
    (indent-for-tab-command))

  (global-set-key (kbd "<C-return>") 'open-line-below)
  (global-set-key (kbd "<C-S-return>") 'open-line-above)
  (global-set-key (kbd "M-j") (lambda () (interactive) (join-line -1)))
  (global-set-key [f7] 'call-last-kbd-macro)
#+END_SRC
** Paredit
#+BEGIN_SRC emacs-lisp
  (use-package paredit
    :diminish paredit-mode
    :config
    (loop for hook in '(emacs-lisp-mode-hook
                        eval-expression-minibuffer-setup-hook
                        ielm-mode-hook lisp-mode-hook
                        lisp-interaction-mode-hook
                        scheme-mode-hook)
          do (add-hook hook #'enable-paredit-mode)))
#+END_SRC

** Autocomplete and snippets
#+BEGIN_SRC emacs-lisp
  (use-package company
    :config
    (progn
      (global-company-mode)
      (setq company-tooltip-align-annotations t
            company-show-numbers t)))

  (use-package yasnippet
    :config
    (yas-global-mode)
    (add-hook 'prog-mode-hook 'yas-minor-mode))

  (setq-default abbrev-mode t)
  (setq save-abbrevs 'silently)

  (use-package angular-snippets)
  (use-package common-lisp-snippets)
#+END_SRC

** Flycheck
All the cool kids seem to be using it.
#+BEGIN_SRC emacs-lisp
    (use-package flycheck
      :init (global-flycheck-mode))
#+END_SRC
** Misc editing facilities
I got most of these from the excellent [[http://emacsrocks.com/][Emacs Rocks]].

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C--") 'bury-buffer)
  (global-set-key (kbd "s--") 'bury-buffer)
  (global-set-key (kbd "C-;") 'comment-line)
  (electric-pair-mode)
  (add-hook 'prog-mode-hook 'subword-mode)

  (use-package expand-region
    :config (pending-delete-mode t)
    :bind
    (("C-=" . er/expand-region)))

  (use-package multiple-cursors
    :bind
    (("C-S-l" . mc/edit-lines)
     ("C->" . mc/mark-next-like-this)
     ("C-<" . mc/mark-previous-like-this)))

  (defun move-line-down ()
    (interactive)
    (let ((col (current-column)))
      (save-excursion
        (forward-line)
        (transpose-lines 1))
      (forward-line)
      (move-to-column col)))

  (defun move-line-up ()
    (interactive)
    (let ((col (current-column)))
      (save-excursion
        (forward-line)
        (transpose-lines -1))
      (forward-line -2)
      (move-to-column col)))

  (global-set-key (kbd "<M-S-up>") 'move-line-up)
  (global-set-key (kbd "<M-S-down>") 'move-line-down)

  ;; Replace upcase/downcase word with their dwim counterparts
  (global-set-key (kbd "M-u") 'upcase-dwim)
  (global-set-key (kbd "M-l") 'downcase-dwim)
  (global-set-key (kbd "C-x C-u") 'upcase-initials-region)
  (global-set-key (kbd "C-x C-l") nil)

  (global-set-key (kbd "s-r") 'rename-buffer)
#+END_SRC

I run many async commands, and not once have I found the confirmation
"A command is running in the default buffer.  Use a new buffer?" useful.

#+BEGIN_SRC emacs-lisp
  (setq async-shell-command-buffer 'rename-buffer)
#+END_SRC

*** Silliness
#+BEGIN_SRC emacs-lisp
  ;;; Super important!!
  (defun shrug ()
    "Insert Â¯\\_(ã)_/Â¯ at point"
    (interactive)
    (insert "Â¯\\_(ã)_/Â¯"))
  (defun lenny ()
    "Insert ( Í¡Â° ÍÊ Í¡Â°) at point"
    (interactive)
    (insert "( Í¡Â° ÍÊ Í¡Â°)"))
#+END_SRC
** Remapping out-of-reach commands
On the Kinesis Advantage, some key combinations are painful to reach (at least
on my RSI'd wrists). Translate some of those here.
#+BEGIN_SRC emacs-lisp
  (define-key key-translation-map (kbd "s-h") (kbd "C-h"))
  ; mapping <escape> to 'keyboard-escape-quit doesn't seem to work for some reason, so we just translate
  (define-key key-translation-map (kbd "<escape>") (kbd "C-g"))

  (define-key key-translation-map (kbd "<s-return>") (kbd "<C-return>"))
  (define-key key-translation-map (kbd "<s-S-return>") (kbd "<C-S-return>"))
#+END_SRC

** Getting help
~which-key~ is useful for discovering keybindings I'm not yet used to.
#+BEGIN_SRC emacs-lisp
  (use-package which-key :ensure t
    :config (which-key-mode))
#+END_SRC
* Backup
#+BEGIN_SRC emacs-lisp
  (defvar --backup-directory (concat user-emacs-directory "backups"))

  (if (not (file-exists-p --backup-directory))
      (make-directory --backup-directory t))

  (setq backup-directory-alist `(("." . ,--backup-directory)))
  (setq make-backup-files t               ; backup of a file the first time it is saved.
        backup-by-copying t               ; don't clobber symlinks
        version-control t                 ; version numbers for backup files
        delete-old-versions t             ; delete excess backup files silently
        delete-by-moving-to-trash t
        kept-old-versions 6               ; oldest versions to keep when a new numbered backup is made (default: 2)
        kept-new-versions 9               ; newest versions to keep when a new numbered backup is made (default: 2)
        auto-save-default t               ; auto-save every buffer that visits a file
        auto-save-timeout 20              ; number of seconds idle time before auto-save (default: 30)
        auto-save-interval 200            ; number of keystrokes between auto-saves (default: 300)
        )
    (setq delete-by-moving-to-trash t)

    (setq backup-directory-alist `(("." . ,(expand-file-name
                                            (concat user-emacs-directory "backups")))))

  (global-auto-revert-mode)               ; revert a fileâs buffer automatically when itâs been changed on disk
#+END_SRC

* Git
Magit is so awesome, it barely needs any setup at all.
#+BEGIN_SRC emacs-lisp
  (use-package magit
    :bind
    (([f8] . magit-status)
     ("M-s-b" . magit-blame)))
#+END_SRC

Scroll wheel moves through time instead of space ([[https://xkcd.com/1806/][ref.]])
#+BEGIN_SRC emacs-lisp
  (defmacro enable-time-machine-and-call (&rest body)
    `(lambda ()
       (interactive)
       (unless (bound-and-true-p git-timemachine-mode)
         (progn
           (message "Enabling git-timemachine mode")
           (git-timemachine)))
       ,@body))

  (use-package git-timemachine
    :config
    (progn
      (global-set-key (kbd "<M-mouse-5>") (enable-time-machine-and-call (git-timemachine-show-next-revision)))
      (global-set-key (kbd "<M-mouse-4>") (enable-time-machine-and-call (git-timemachine-show-previous-revision)))))
#+END_SRC

* Shell
Based on the excellent config and article from [[https://github.com/howardabrams/dot-files/blob/master/emacs-eshell.org][Howard Abrams]]. Code will mostly
be different as it turns out that most of his config doesnât really work for me,
but the ideas are pretty darn good.

First of all, we need a convenient way to spawn shells.
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "<f1>") 'eshell)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defun eshell-here ()
    "Opens up a new shell in the directory associated with the
  current buffer's file. The eshell is renamed to match that
  directory to make multiple eshell windows easier."
    (interactive)
    (let* ((parent (if (buffer-file-name)
                       (file-name-directory (buffer-file-name))
                     default-directory))
           (height (/ (window-total-height) 3))
           (name   (car (last (split-string parent "/" t)))))
      (split-window-vertically (- height))
      (other-window 1)
      (eshell "new")
      (rename-buffer (concat "*eshell: " name "*"))

      (insert "ls")
      (eshell-send-input)))

  (global-set-key (kbd "C-!") 'eshell-here)
  (defun eshell/x ()
    (delete-window)
    (eshell/exit))
#+END_SRC

Some executables donât behave well with Eshell out of the box, so we tweak them a little.
#+BEGIN_SRC emacs-lisp
  (add-hook 'eshell-mode-hook (lambda ()
      (add-to-list 'eshell-visual-commands "ssh")
      (add-to-list 'eshell-visual-commands "tail")))
#+END_SRC

I canât believe you can start an Eshell session remotely via Tramp.
#+BEGIN_SRC emacs-lisp
  (defun eshell-there (host)
    (interactive "sHost: ")
    (let ((default-directory (format "/%s:" host)))
      (eshell host)))
#+END_SRC

** Aliases
#+BEGIN_SRC emacs-lisp
  (defun eshell/d (&rest args)
    (dired (pop args) "."))
#+END_SRC
** Prompt
First, we need a function to tell us the current git branch.

#+BEGIN_SRC emacs-lisp
  (defun curr-dir-git-branch-string (pwd)
    "Returns current git branch as a string, or the empty string if
  PWD is not in a git repo (or the git command is not found)."
    (interactive)
    (when (and (eshell-search-path "git")
               (locate-dominating-file pwd ".git"))
      (let ((git-output (shell-command-to-string (concat "cd " pwd " && git branch | grep '\\*' | sed -e 's/^\\* //'"))))
        (if (> (length git-output) 0)
            (concat " :" (substring git-output 0 -1))
          "(no branch)"))))
#+END_SRC

The function takes the current directory passed in via =pwd= and
replaces the =$HOME= part with a tilde. Iâm sure this function already
exists in the eshell source, but I didnât find itâ¦

#+BEGIN_SRC emacs-lisp
  (defun pwd-replace-home (pwd)
    "Replace home in PWD with tilde (~) character."
    (interactive)
    (let* ((home (expand-file-name (getenv "HOME")))
           (home-len (length home)))
      (if (and
           (>= (length pwd) home-len)
           (equal home (substring pwd 0 home-len)))
          (concat "~" (substring pwd home-len))
        pwd)))
#+END_SRC

Make the directory name be shorterâ¦by replacing all directory names
with just its first names. However, we leave the last two to be the
full names. Why yes, I did steal this.

#+BEGIN_SRC emacs-lisp
  (defun pwd-shorten-dirs (pwd)
    "Shorten all directory names in PWD except the last two."
    (let ((p-lst (split-string pwd "/")))
      (if (> (length p-lst) 2)
          (concat
           (mapconcat (lambda (elm) (if (zerop (length elm)) ""
                                 (substring elm 0 1)))
                      (butlast p-lst 2)
                      "/")
           "/"
           (mapconcat (lambda (elm) elm)
                      (last p-lst 2)
                      "/"))
        pwd)))  ;; Otherwise, we just return the PWD
#+END_SRC

Break up the directory into a âparentâ and a âbaseâ:

#+BEGIN_SRC emacs-lisp
  (defun split-directory-prompt (directory)
    (if (string-match-p ".*/.*" directory)
        (list (file-name-directory directory) (file-name-base directory))
      (list "" directory)))
#+END_SRC

Now tie it all together with a prompt function can color each of the
prompts components and turn off the default one.

#+BEGIN_SRC emacs-lisp
  (setq eshell-prompt-function
        (lambda ()
          (let* ((directory (split-directory-prompt (pwd-shorten-dirs (pwd-replace-home (eshell/pwd)))))
                 (parent (car directory))
                 (name (cadr directory))
                 (branch (or (curr-dir-git-branch-string (eshell/pwd)) "")))

            (if (eq 'dark (frame-parameter nil 'background-mode))
                (concat   ;; Prompt for Dark Themes
                 (propertize parent 'face `(:foreground "#8888FF"))
                 (propertize name   'face `(:foreground "#8888FF" :weight bold))
                 (propertize branch 'face `(:foreground "green"))
                 (propertize " $"   'face `(:weight ultra-bold))
                 (propertize " "    'face `(:weight bold)))

              (concat    ;; Prompt for Light Themes
               (propertize parent 'face `(:foreground "blue"))
               (propertize name   'face `(:foreground "blue" :weight bold))
               (propertize branch 'face `(:foreground "dark green"))
               (propertize " $"   'face `(:weight ultra-bold))
               (propertize " "    'face `(:weight bold)))))))

  (setq eshell-highlight-prompt nil)
#+END_SRC

** Import some variables from the shell
#+BEGIN_SRC emacs-lisp
  (use-package exec-path-from-shell
    :config
    (progn
      (exec-path-from-shell-copy-env "PATH")
      (exec-path-from-shell-copy-env "SSH_AGENT_PID")
      (exec-path-from-shell-copy-env "GOPATH")
      (exec-path-from-shell-copy-env "SSH_AUTH_SOCK")))
#+END_SRC
* Mode-specific
** JavaScript
#+BEGIN_SRC emacs-lisp
  (use-package js2-mode
    :mode ("\\.jsx\\'" "\\.js\\'")
    :bind
    (:map js2-mode-map ("C-c C-c" . js-send-region))
    :config
    (progn
      (setq js2-basic-offset 2
            js2-strict-trailing-comma-warning nil
            js2-global-externs
            '("angular" "d3" "require" "karma" "it" "describe" "beforeEach" "module"))
      (add-hook 'js2-mode-hook 'js2-imenu-extras-mode)
      (define-key js2-mode-map (kbd "M-j") nil)))

  (use-package js2-refactor
    :ensure t
    :bind
    (:map js2-refactor-mode-map
          ("C-k" . js2r-kill)
          ("<M-S-up>" . js2r-move-line-up)
          ("<M-S-down>" . js2r-move-line-down)
          ("s-r" . js2r-rename-var))
    :config
    (progn
      (add-hook 'js2-mode-hook 'js2-refactor-mode)
      (js2r-add-keybindings-with-prefix "C-c C-r")))

  (use-package tide
    :config
    (progn
      (setq tide-completion-detailed t
            tide-completion-enable-autoimport-suggestions t
            tide-always-show-documentation t)

      (defun setup-tide-mode ()
        (tide-setup)
        (eldoc-mode +1)
        (tide-hl-identifier-mode +1))

      (add-hook 'typescript-mode-hook 'setup-tide-mode)
      (add-hook 'js2-mode-hook 'setup-tide-mode)

      (flycheck-add-next-checker 'javascript-eslint 'javascript-tide 'append)))
#+END_SRC
** Common Lisp
Nothing fancy here, just a regular SLIME installation.
#+BEGIN_SRC emacs-lisp
  (use-package slime
    :config
    (progn
      (setq inferior-lisp-program "/usr/bin/sbcl"
            slime-net-coding-system 'utf-8-unix)
      (slime-setup '(slime-fancy))
      (set-language-environment "UTF-8")
      (setenv "LC_LOCALE" "en_US.UTF-8")
      (setenv "LC_CTYPE" "en_US.UTF-8")))
#+END_SRC
** Web
#+BEGIN_SRC emacs-lisp
  (use-package emmet-mode
    :config
    (progn
      (add-hook 'web-mode-hook 'emmet-mode)
      (add-hook 'sgml-mode-hook 'emmet-mode)
      (add-hook 'css-mode-hook emmet-mode)
      (setq emmet-self-closing-tag-style ""
            emmet-indentation 2
            css-mode-indent-offset 2))
    (define-key emmet-mode-keymap (kbd "<C-return>") nil))

  (use-package web-mode
    :mode ("\\.php\\'" "\\.css\\'" "\\.tpl\\â" "\\.less\\'")
    :bind
    (:map web-mode-map
          ("C-M-u" . web-mode-element-parent)
          ("C-M-d" . web-mode-element-child)
          ("C-M-n" . web-mode-element-next)
          ("C-M-p" . web-mode-element-previous))
    :config
    (setq-default web-mode-css-indent-offset 2
                  web-mode-code-indent-offset 2
                  web-mode-markup-indent-offset 2
                  web-mode-attr-indent-offset nil
                  css-indent-offset 2)
    ;; the docs say these have to be defined in a hook
    (add-hook 'web-mode-hook (lambda ()
                               (setq web-mode-enable-css-colorization t
                                     web-mode-enable-current-element-highlight t
                                     web-mode-code-indent-offset 2
                                     js-indent-level 2
                                     web-mode-auto-close-style 1
                                     web-mode-enable-auto-indentation t
                                     web-mode-enable-auto-opening t
                                     web-mode-enable-auto-pairing t
                                     web-mode-enable-auto-quoting t
                                     web-mode-attr-indent-offset nil
                                     web-mode-attr-indent-offset nil)))
    (setq web-mode-ac-sources-alist
          '(("css" . (ac-source-css-property))
            ("html" . (ac-source-words-in-buffer ac-source-abbrev))))
    (add-hook 'web-mode-hook 'turn-off-fci-mode))

  (use-package less-css-mode
    :mode ("\\.less$" . less-css-mode))

  (defun php-tpl-localize (p1 p2)
    "Wrap region in a PHP call to xgettext.
  Called interactively, use the selected region.
  When called from Lisp, use delimiters P1 and P2."
    (interactive "r")
    (save-mark-and-excursion
     (goto-char p1)
     (insert "<?= _('")
     (setq begin (point))
     (forward-char (- p2 p1))
     (setq end (point))
     (insert "') ?>")
     (replace-string "'" "\\'" nil begin end)
     (message "Localized region")))
#+END_SRC
** Dired
Note that you'll need to call ~all-the-icons-install-fonts~ if you don't have the
required fonts installed (likely).

#+BEGIN_SRC emacs-lisp
  (use-package all-the-icons-dired
    :diminish all-the-icons-dired-mode
    :config
    (add-hook 'dired-mode-hook 'all-the-icons-dired-mode))

  (add-hook 'dired-mode-hook 'dired-hide-details-mode)
  (setq dired-dwim-target t)              ; move/copy files across dired buffers
#+END_SRC

** Go
Please note that this configuration requires quite a bit of external tools and
resources. You'll need at least to get the extra tools (~go get -u
golang.org/x/tools/cmd/...~), but there may be more dependencies missing here.

#+BEGIN_SRC emacs-lisp
  (use-package go-mode
    :config
    (setq gofmt-command "goimports")

    (defun go-compile ()
      (interactive)
      (compile "go build"))

    (defun go-test ()
      (interactive)
      (compile "go test"))

    (define-key go-mode-map (kbd "C-\\") 'go-compile)
    (define-key go-mode-map (kbd "M-\\") 'go-test)

    (add-hook 'go-mode-hook (lambda ()
                              (add-hook 'before-save-hook 'gofmt-before-save))))

  (use-package go-eldoc
    :config
    (add-hook 'go-mode-hook 'go-eldoc-setup))

  (use-package company-go
    :config
    (add-hook 'go-mode-hook (lambda ()
                              (set (make-local-variable 'company-backends) '(company-go))
                              (company-mode))))

  (use-package go-guru
    :bind
    (:map go-mode-map
          ("M-." . go-guru-definition)
          ("M-," . pop-tag-mark))
    :config
    (add-hook 'go-mode-hook 'go-guru-hl-identifier-mode))
#+END_SRC
** Org
#+BEGIN_SRC emacs-lisp
  (use-package org
    :bind
    (:map org-mode-map
          ("M-[" . org-set-tags)
          ("C-c s" . org-sort)
          ("<C-up>" . org-up-element)
          ("<C-down>" . org-down-element)
          ("s-t" . org-todo))
    :config
    (progn
      ;; For some reason, declaring these in `:bind` won't work
      (global-set-key (kbd "C-c b") 'org-iswitchb)
      (global-set-key (kbd "C-c j") 'org-clock-goto)
      (global-set-key (kbd "<f2>") 'org-capture)
      (global-set-key (kbd "<f3>") 'org-agenda)
      (global-set-key (kbd "C-c c") 'org-capture)
      (global-set-key (kbd "C-c a") 'org-agenda)

      (define-key org-mode-map (kbd "M-s-i") 'org-clock-in)
      (define-key org-mode-map (kbd "M-s-o") 'org-clock-out)

      ;; run shell commands from org-babel
      (defvar -org-babel-langs '((sh . t) (python . t)))
      (setq org-babel-python-command "python3")
      (org-babel-do-load-languages 'org-babel-load-languages -org-babel-langs)

      ;; display/update images in the buffer after I evaluate
      (add-hook 'org-babel-after-execute-hook 'org-display-inline-images 'append)

      (add-hook 'org-mode-hook 'auto-fill-mode)

      ;; Link to manpages from org
      (org-add-link-type "man" 'org-man-open)
      (add-hook 'org-store-link-functions 'org-man-store-link)

      (defcustom org-man-command 'man
        "The Emacs command to be used to display a man page."
        :group 'org-link
        :type '(choice (const man) (const woman)))

      (defun org-man-open (path)
        "Visit the manpage on PATH.
  PATH should be a topic that can be thrown at the man command."
        (funcall org-man-command path))

      (defun org-man-store-link ()
        "Store a link to a manpage."
        (when (memq major-mode '(Man-mode woman-mode))
          ;; This is a man page, we do make this link
          (let* ((page (org-man-get-page-name))
                 (link (concat "man:" page))
                 (description (format "Manpage for %s" page)))
            (org-store-link-props
             :type "man"
             :link link
             :description description))))

      (defun org-man-get-page-name ()
        "Extract the page name from the buffer name."
        ;; This works for both `Man-mode' and `woman-mode'.
        (if (string-match " \\(\\S-+\\)\\*" (buffer-name))
            (match-string 1 (buffer-name))
          (error "Cannot create link to this man page")))

      (setq org-agenda-include-diary t
            org-log-reschedule 'note
            org-log-done 'time
            org-enforce-todo-dependencies t
            org-enforce-todo-checkbox-dependencies t
            org-fontify-whole-heading-line t
            org-fontify-done-headline t
            org-fontify-quote-and-verse-blocks t
            org-hide-emphasis-markers t
            org-agenda-restore-windows-after-quit t
            org-src-fontify-natively t     ; syntax highlight in code blocks
            org-return-follows-link t      ; return opens links
            org-confirm-babel-evaluate nil ; stop prompting for confirmation on eval
            org-src-tab-acts-natively t    ; make TAB behave as expected in src blocks
            org-support-shift-select nil
            org-refile-targets '((nil :maxlevel . 3)
                                 ("~/Org/work.org" :maxlevel . 1)
                                 ("~/Org/gtd.org" :maxlevel . 3)
                                 ("~/Org/someday.org" :maxlevel . 1)
                                 ("~/Org/tickler.org" :maxlevel . 2))
            org-outline-path-complete-in-steps nil ; Refile in a single go
            org-refile-use-outline-path 'file      ; Refile to top-level
            org-todo-keywords
            '((sequence "TODO(t)" "WAITING(w)" "|" "DONE(d)" "CANCELLED(c)")))))

  (use-package org-pomodoro
    :commands (org-pomodoro)
    :bind ("C-S-p" . org-pomodoro)
    :config
    (setq alert-user-configuration (quote ((((:category . "org-pomodoro")) libnotify nil)))))
#+END_SRC

*** Getting Things Done
This is a new section as I'm experimenting with implementing GTD in org-mode. I'll likely refile it soon.

I want to be able to quickly file new items to my inbox. Let's do so via capture templates.
#+BEGIN_SRC emacs-lisp
  (setq org-capture-templates '(("t" "Todo [inbox]" entry
                                 (file+headline "~/Org/inbox.org" "Inbox")
                                 "* TODO %i%?")
                                ("T" "Tickler" entry
                                 (file+headline "~/Org/tickler.org" "Tickler")
                                 "* %i%? \n %^t")
                                ("j" "Journal entry" entry
                                 (file+datetree "~/Org/journal.org")
                                 "* %?")))
#+END_SRC

What I need now are [[http://orgmode.org/worg/org-tutorials/org-custom-agenda-commands.html][custom agenda commands]] to filter my backlog.
#+BEGIN_SRC emacs-lisp
  (setq org-agenda-custom-commands
        '(("n" "Next actions" alltodo nil
           ((org-agenda-overriding-header "Next actions")
            (org-agenda-skip-function #'my-org-agenda-skip-all-siblings-but-first)))
          ("w" "Next actions (work)" tags-todo "WORK"
           ((org-agenda-overriding-header "Work tasks")
            (org-agenda-skip-function #'my-org-agenda-skip-all-siblings-but-first)))
          ("W" "Waiting for..." todo "WAITING")))

  (defun my-org-agenda-skip-all-siblings-but-first ()
    "Skip all but the first non-done entry."
    (let (should-skip-entry)
      (unless (org-current-is-todo)
        (setq should-skip-entry t))
      (save-excursion
        (while (and (not should-skip-entry) (org-goto-sibling t))
          (when (org-current-is-todo)
            (setq should-skip-entry t))))
      (when should-skip-entry
        (or (outline-next-heading)
            (goto-char (point-max))))))

  (defun org-current-is-todo ()
    (string= "TODO" (org-get-todo-state)))

  (setq org-agenda-files '("~/Org/tickler.org" "~/Org/work.org" "~/Org/gtd.org"))
#+END_SRC
** Other
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "M-p") 'compile)
(global-set-key (kbd "M-P") 'recompile)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("\\.hdl\\'" . vhdl-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package inf-ruby
    :config (add-hook 'ruby-mode-hook 'inf-ruby-minor-mode)
    :bind
    (:map inf-ruby-minor-mode-map
          ("C-c C-c" . ruby-send-buffer)
          ("C-c C-e" . ruby-send-last-sexp)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
    (use-package puppet-mode
      :config
      (setq-default puppet-indent-level 4))
#+END_SRC
** RSS + Pocket
#+BEGIN_SRC emacs-lisp
  (use-package elfeed
    :config
    (setq elfeed-feeds '("https://jvns.ca/atom.xml"
                         "http://blog.ricbit.com/feeds/posts/default"
                         "https://sivers.org/en.atom"
                         "https://wingolog.org/feed/atom"
                         "https://lobste.rs/rss"
                         "https://codewithoutrules.com/atom.xml"
                         "https://blog.jessfraz.com/index.xml"
                         "http://feeds.feedburner.com/zenhabits"
                         "http://lisperator.net/atom"
                         "http://n-gate.com/index.atom"
                         "http://emacsrocks.com/atom.xml"
                         "https://www.destroyallsoftware.com/screencasts/feed"
                         "https://www.masteringemacs.org/feed"
                         ("http://xahlee.info/math/blog.xml" xah-lee)
                         ("http://xahlee.info/js/blog.xml" xah-lee)
                         ("http://xahlee.info/comp/blog.xml" xah-lee))))

  (use-package pocket-reader)
#+END_SRC
* Startup
#+BEGIN_SRC emacs-lisp
  (defun initial-window-setup ()
    "Initially set up split windows and buffers"
    (interactive)
    (org-agenda-list)
    (other-window +1)
    (find-file "~/Org/inbox.org")
    (split-window-below)
    (other-window +1)
    (cd "~")
    (eshell))

  (add-hook 'after-init-hook 'initial-window-setup)
#+END_SRC
* Mail
I'm trying out mu4e, let's see how this goes
#+BEGIN_SRC emacs-lisp
    (add-to-list 'load-path "/usr/share/emacs/site-lisp/mu4e")
    (require 'mu4e)
#+END_SRC
* Custom file
The custom file holds all auto-generated Emacs configs, which I use for Org-mode
quite a lot. This is so my =init.el= doesn't get littered by auto-generated stuff.
#+BEGIN_SRC emacs-lisp
(setq custom-file "~/.emacs.d/custom.el")
(load custom-file :noerror)
#+END_SRC
