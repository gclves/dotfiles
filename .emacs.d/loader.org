#+TITLE: GNU Emacs configuration
#+STARTUP: indent
#+LAYOUT: post
#+OPTIONS: H:5 num:nil tags:nil toc:nil timestamps:t
#+DESCRIPTION: Loading Emacs configuration using org-babel
#+TAGS: emacs

* Who am I
#+BEGIN_SRC emacs-lisp
  (setq user-full-name "Guilherme Goncalves"
        user-email-address "gsg@ggoncalves.me")
#+END_SRC
* Window setup
I like to set the appearance as early as possible to avoid glitches in
the loading process. This makes for a cleaner Emacs window.

#+BEGIN_SRC emacs-lisp
  (if (fboundp 'tool-bar-mode) (tool-bar-mode -1))
  (if (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
  (global-hl-line-mode t)
  (fringe-mode 1) ; 1px fringe
  (column-number-mode)
  (blink-cursor-mode)
  (tooltip-mode -1)
  (setq inhibit-startup-message t
        initial-scratch-message ""
        mode-line-default-help-echo nil
        indicate-buffer-boundaries nil
        indicate-empty-lines nil
        cursor-in-non-selected-windows nil
        highlight-nonselected-windows nil
        bidi-display-reordering nil
        blink-matching-paren nil)
#+END_SRC

This config file is used across multiple computers and different OSes, which
render fonts quite differently. This might be overkill, but I want to have a
list of options of fonts to render so we don't end up with garbage.

#+BEGIN_SRC emacs-lisp
  (let ((font-list '(("Fantasque Sans Mono" . 16) ("Inconsolata" . 16)))
        (supported-fonts (font-family-list))
        (format-font-name (lambda (font)
                            (destructuring-bind (font-name . font-size) font
                              (concat font-name "-" (number-to-string font-size))))))
    (some (lambda (font) (when (member (car font) supported-fonts)
                      (set-default-font (funcall format-font-name font))
                      t))
          font-list))
#+END_SRC

* Package setup
#+BEGIN_SRC emacs-lisp
    (require 'package)
    (setq package-archives '(("gnu" . "https://elpa.gnu.org/packages/")
                             ("org" . "http://orgmode.org/elpa/")
                             ("marmalade" . "https://marmalade-repo.org/packages/")
                             ("melpa" . "https://melpa.org/packages/")))
  (package-initialize)

  (unless package-archive-contents
    (package-refresh-contents))

  (unless (package-installed-p 'use-package)
    (package-initialize)
    (package-install 'use-package))

  (setq use-package-always-ensure t)

#+END_SRC

* Look and feel
** Other customizations
This replaces some words with their Math symbols (eg: lambda => λ).
#+BEGIN_SRC emacs-lisp
  (global-prettify-symbols-mode 1)
#+END_SRC

Prettier Unicode symbols.
#+BEGIN_SRC emacs-lisp
  (when (member "Symbola" (font-family-list))
    (set-fontset-font t 'unicode "Symbola" nil 'prepend))
#+END_SRC

Highlight changes in the gutter
#+BEGIN_SRC emacs-lisp
  (use-package git-gutter
    :diminish git-gutter-mode
    :init (global-git-gutter-mode +1)
    :config
    (setq git-gutter:update-interval 2)
    (mapc (lambda (pair)
            (set-face-background (car pair) (cdr pair))
            (set-face-foreground (car pair) (cdr pair)))
          '((git-gutter:added . "#8bc34a")
            (git-gutter:modified . "#b39ddb")
            (git-gutter:deleted . "#f36c60")))
    :bind
    (("C-c C-n" . git-gutter:next-hunk)
     ("C-c C-p" . git-gutter:previous-hunk)))
#+END_SRC

Show time and status information on the modeline, so we can go fullscreen and
don't depend on the OS.
#+BEGIN_SRC emacs-lisp
  (setq display-time-default-load-average 0) ; 1-minute load average
  (display-time-mode)
  (display-battery-mode)
#+END_SRC
*** Highlight TODO entries
#+BEGIN_SRC emacs-lisp
  (use-package hl-todo
    :init (global-hl-todo-mode)
    :bind
    (:map hl-todo-mode-map
          ("C-c <up>" . hl-todo-previous)
          ("C-c <down>" . hl-todo-next)
          ("C-c T" . hl-todo-occur)))
#+END_SRC
*** Miscellaneous
#+BEGIN_SRC emacs-lisp
  ;;; Display rules at column 80
  (setq-default fill-column 80)
  (use-package fill-column-indicator
    :config
    (add-hook 'prog-mode-hook 'fci-mode))
#+END_SRC

* Editing goodies
** Ain't nobody got time for typing "yes"/"no".
#+BEGIN_SRC emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC
** Interactively do things
#+BEGIN_SRC emacs-lisp
  (use-package ivy
    :bind
    (:map global-map
          ("s-f" . swiper)
          ("s-b" . ivy-switch-buffer)
          ("s-g" . ivy-resume)
          ("M-x" . counsel-M-x)
          ("C-x C-f" . counsel-find-file)
          ("s-o" . counsel-find-file)
          ("<f6> f" . counsel-describe-function)
          ("<f6> v" . counsel-describe-variable)
          ("<f6> l" . counsel-find-library)
          ("<f6> i" . counsel-info-lookup-symbol)
          ("<f6> u" . counsel-unicode-char)
          ("C-c g" . counsel-git)
          ("C-c G" . counsel-git-grep)
          ("M-S-f" . counsel-ag)
          ("C-x l" . counsel-locate)
          ("C-c i" . counsel-imenu)
          ("s-i" . counsel-imenu)
          :map minibuffer-local-map
          ("C-r" . counsel-minibuffer-history))
    :config
    (progn
      (setq ivy-use-virtual-buffers 1
            ivy-use-selectable-prompts 0
            enable-recursive-minibuffers 1))
    :init (ivy-mode))

  (use-package projectile
    :bind
    (("s-&" . projectile-run-async-shell-command-in-root)
     ("s-!" . projectile-run-eshell)
     ("C-!" . projectile-run-shell-command-in-root)
     ("C-c C-e" . projectile-run-eshell)
     ("C-c C-s" . projectile-run-shell)
     ("C-\\" . projectile-find-file)
     ("s-p" . projectile-find-file)
     ("M-F" . projectile-ag))
    :init (projectile-mode)
    :config
    (progn
      (setq projectile-completion-system 'ivy)

      (defun run-grunt ()
        "Runs the command \"grunt fwatch\" on the projectile
        root. Splits the current window and display the output in
        a new buffer named *grunt*. In the *grunt* buffer, C-c C-c
        kills the process and closes the window."
        (interactive)
        (let ((buffer (get-buffer-create "*grunt*"))
              (height (/ (window-total-height) 3)))
          (split-window-below (- height))
          (other-window 1)
          (switch-to-buffer buffer)
          (comint-mode)
          (local-set-key (kbd "C-c C-c") (lambda ()
                                           (interactive)
                                           (comint-kill-subjob)
                                           (kill-buffer-and-window)))
          (cd (projectile-project-root))
          (start-process "grunt" buffer "grunt" "fwatch" "--no-color")
          (other-window -1)))
      (define-key projectile-mode-map (kbd "<f5>") 'run-grunt)))

  (use-package counsel-projectile
    :bind ("C-S-f" . counsel-projectile-ag))
#+END_SRC

** Moving around
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-S-w") (lambda () (interactive) (kill-buffer nil)))
  (global-set-key (kbd "C-b") 'ido-switch-buffer)
  (global-set-key (kbd "M-o") 'next-multiframe-window)
  (global-set-key (kbd "M-O") 'previous-multiframe-window)

  (global-set-key (kbd "M-3") 'delete-other-windows)
  (global-set-key (kbd "M-4") 'split-window-below)
  (global-set-key (kbd "M-$") 'split-window-right)
  (global-set-key (kbd "M-9") 'delete-window)

  (windmove-default-keybindings 'super)
  (setq windmove-wrap-around t)

  ; no more janky scrolling
  (setq scroll-conservatively 100)

  (use-package undo-tree
    :diminish undo-tree-mode
    :bind
    (("C-z" . undo-tree-undo)
     ("C-S-z" . undo-tree-redo)
     ("s-z" . undo-tree-undo)
     ("s-S-z" . undo-tree-redo)
     ("s-Z" . undo-tree-redo)
     ("C-x u" . undo-tree-visualize)
     ("<S-mouse-4>" . undo-tree-undo)
     ("<S-mouse-5>" . undo-tree-redo))
    :config
    (global-undo-tree-mode))

  (use-package zoom-window
    :bind
    (("M-1" . zoom-window-zoom)))

  (defun jump-to-scratch ()
    (interactive)
    (switch-to-buffer "*scratch*"))
  (global-set-key (kbd "M--") 'jump-to-scratch)

  (defun back-to-indentation-or-beginning ()
    "Move point to beginning of line, or to first non-space character"
    (interactive)
    (if (= (point) (progn (back-to-indentation) (point)))
        (beginning-of-line)))
  (global-set-key (kbd "<home>") 'back-to-indentation-or-beginning)
  (global-set-key (kbd "C-a") 'back-to-indentation-or-beginning)

  (defun goto-line-with-feedback ()
    "Show line numbers temporarily, while prompting for the line number input"
    (interactive)
    (unwind-protect
        (progn
          (linum-mode 1)
          (goto-line (read-number "Goto line: ")))
      (linum-mode -1)))
  (global-set-key [remap goto-line] 'goto-line-with-feedback)
#+END_SRC

** Get rid of useless whitespace
#+BEGIN_SRC emacs-lisp
  (use-package ws-butler
    :config (ws-butler-global-mode)
    :diminish ws-butler-mode)

  (defun cleanup-buffer-safe ()
    "Perform a bunch of safe operations on the whitespace content.
  For a more agressive cleanup that also does indentation, use
  cleanup-buffer."
    (interactive)
    (untabify (point-min) (point-max))
    (set-buffer-file-coding-system 'utf-8))

  (defun cleanup-buffer ()
    "Perform a bunch of operations on the whitespace content of a buffer.
  Including indent-buffer, which should not be called automatically on save."
    (interactive)
    (whitespace-cleanup)
    (cleanup-buffer-safe)
    (indent-region (point-min) (point-max)))

  (global-set-key (kbd "C-c N") 'cleanup-buffer)
  (global-set-key (kbd "C-c n") 'cleanup-buffer-safe)

  (global-set-key (kbd "RET") 'newline-and-indent)

  (setq fill-column 80)
  (setq-default indent-tabs-mode nil)

  ;; Render all whitespace: useful, but crowded
  ;; (setq whitespace-style '(face trailing tabs newline tab-mark space-mark))
  (setq whitespace-style '(face trailing tabs newline))
  (setq whitespace-display-mappings
        '((tab-mark 9 [8594 9])
          (space-mark 32 [183] [46])
          (space-mark 160 [164])
          (newline-mark 10 [8617 10])))

  (add-hook 'prog-mode-hook 'whitespace-mode)
#+END_SRC

** Copy-paste goodness stolen from Xah Lee
#+BEGIN_SRC emacs-lisp
  (defun xah-cut-line-or-region ()
    "Cut current line, or text selection.
  When `universal-argument' is called first, cut whole buffer (respects `narrow-to-region')."
    (interactive)
    (if current-prefix-arg
        (progn ; not using kill-region because we don't want to include previous kill
          (kill-new (buffer-string))
          (delete-region (point-min) (point-max)))
      (progn (if (use-region-p)
                 (kill-region (region-beginning) (region-end) t)
               (kill-whole-line)))))

  (defun xah-copy-line-or-region ()
    "Copy current line, or text selection.
  When called repeatedly, append copy subsequent lines.
  When `universal-argument' is called first, copy whole buffer (respects `narrow-to-region')."
    (interactive)
    (let (-p1 -p2)
      (if current-prefix-arg
          (setq -p1 (point-min) -p2 (point-max))
        (if (use-region-p)
            (setq -p1 (region-beginning) -p2 (region-end))
          (setq -p1 (line-beginning-position) -p2 (line-end-position))))
      (if (eq last-command this-command)
          (progn
            (progn ; hack. exit if there's no more next line
              (end-of-line)
              (forward-char)
              (backward-char))
            (push-mark (point) "NOMSG" "ACTIVATE")
            (kill-append "\n" nil)
            (kill-append (buffer-substring-no-properties (line-beginning-position) (line-end-position)) nil)
            (message "Line copy appended"))
        (progn
          (kill-ring-save -p1 -p2)
          (if current-prefix-arg
              (message "Buffer text copied")
            (message "Text copied"))))
      (end-of-line)
      (forward-char)))

  (global-set-key (kbd "C-w") 'xah-cut-line-or-region)
  (global-set-key (kbd "s-x") 'xah-cut-line-or-region)
  (global-set-key (kbd "M-w") 'xah-copy-line-or-region)
  (global-set-key (kbd "s-c") 'xah-copy-line-or-region)
#+END_SRC

** Manipulate a file directly from its buffer
#+BEGIN_SRC emacs-lisp
  (defun delete-current-buffer-file ()
    "Removes file connected to current buffer and kills buffer."
    (interactive)
    (let ((filename (buffer-file-name))
          (buffer (current-buffer))
          (name (buffer-name)))
      (if (not (and filename (file-exists-p filename)))
          (ido-kill-buffer)
        (when (yes-or-no-p "Are you sure you want to remove this file? ")
          (delete-file filename)
          (kill-buffer buffer)
          (message "File '%s' successfully removed" filename)))))
  (global-set-key (kbd "C-x C-k") 'delete-current-buffer-file)

  (defun rename-current-buffer-file ()
    "Renames current buffer and file it is visiting."
    (interactive)
    (let ((name (buffer-name))
          (filename (buffer-file-name)))
      (if (not (and filename (file-exists-p filename)))
          (error "Buffer '%s' is not visiting a file!" name)
        (let ((new-name (read-file-name "New name: " filename)))
          (if (get-buffer new-name)
              (error "A buffer named '%s' already exists!" new-name)
            (rename-file filename new-name 1)
            (rename-buffer new-name)
            (set-visited-file-name new-name)
            (set-buffer-modified-p nil)
            (message "File '%s' successfully renamed to '%s'"
                     name (file-name-nondirectory new-name)))))))
  (global-set-key (kbd "C-x C-r") 'rename-current-buffer-file)

#+END_SRC

** Open line
#+BEGIN_SRC emacs-lisp
  (defun open-line-below ()
    (interactive)
    (end-of-line)
    (newline)
    (indent-for-tab-command))

  (defun open-line-above ()
    (interactive)
    (beginning-of-line)
    (newline)
    (forward-line -1)
    (indent-for-tab-command))

  (global-set-key (kbd "<C-return>") 'open-line-below)
  (global-set-key (kbd "<C-S-return>") 'open-line-above)
  (global-set-key (kbd "M-j") (lambda () (interactive) (join-line -1)))
  (global-set-key [f7] 'call-last-kbd-macro)
#+END_SRC
** Paredit
#+BEGIN_SRC emacs-lisp
  (use-package paredit
    :diminish paredit-mode
    :config
    (loop for hook in '(emacs-lisp-mode-hook
                        eval-expression-minibuffer-setup-hook
                        ielm-mode-hook lisp-mode-hook
                        lisp-interaction-mode-hook
                        scheme-mode-hook)
          do (add-hook hook #'enable-paredit-mode)))
#+END_SRC

** Autocomplete and snippets
#+BEGIN_SRC emacs-lisp
  (use-package company
    :config
    (progn
      (global-company-mode)
      (setq company-tooltip-align-annotations t
            company-show-numbers t)))

  (use-package yasnippet
    :config
    (yas-global-mode)
    (add-hook 'prog-mode-hook 'yas-minor-mode))

  (setq-default abbrev-mode t)
  (setq save-abbrevs 'silently)

  (use-package angular-snippets)
  (use-package common-lisp-snippets)
#+END_SRC

** Flycheck
All the cool kids seem to be using it.
#+BEGIN_SRC emacs-lisp
    (use-package flycheck
      :init (global-flycheck-mode))
#+END_SRC
** Misc editing facilities
I got most of these from the excellent [[http://emacsrocks.com/][Emacs Rocks]].

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C--") 'bury-buffer)
  (global-set-key (kbd "s--") 'bury-buffer)
  (global-set-key (kbd "C-;") 'comment-line)
  (electric-pair-mode)
  (add-hook 'prog-mode-hook 'subword-mode)

  (use-package expand-region
    :config (pending-delete-mode t)
    :bind
    (("C-=" . er/expand-region)))

  (use-package multiple-cursors
    :bind
    (("C-S-l" . mc/edit-lines)
     ("C->" . mc/mark-next-like-this)
     ("C-<" . mc/mark-previous-like-this)))

  (defun move-line-down ()
    (interactive)
    (let ((col (current-column)))
      (save-excursion
        (forward-line)
        (transpose-lines 1))
      (forward-line)
      (move-to-column col)))

  (defun move-line-up ()
    (interactive)
    (let ((col (current-column)))
      (save-excursion
        (forward-line)
        (transpose-lines -1))
      (forward-line -2)
      (move-to-column col)))

  (global-set-key (kbd "<M-S-up>") 'move-line-up)
  (global-set-key (kbd "<M-S-down>") 'move-line-down)

  ;; Replace upcase/downcase word with their dwim counterparts
  (global-set-key (kbd "M-u") 'upcase-dwim)
  (global-set-key (kbd "M-l") 'downcase-dwim)
  (global-set-key (kbd "C-x C-u") 'upcase-initials-region)
  (global-set-key (kbd "C-x C-l") nil)

  (global-set-key (kbd "s-r") 'rename-buffer)
#+END_SRC

I run many async commands, and not once have I found the confirmation
"A command is running in the default buffer.  Use a new buffer?" useful.

#+BEGIN_SRC emacs-lisp
  (setq async-shell-command-buffer 'rename-buffer)
#+END_SRC

*** Silliness
#+BEGIN_SRC emacs-lisp
  ;;; Super important!!
  (defun shrug ()
    "Insert ¯\\_(ツ)_/¯ at point"
    (interactive)
    (insert "¯\\_(ツ)_/¯"))
  (defun lenny ()
    "Insert ( ͡° ͜ʖ ͡°) at point"
    (interactive)
    (insert "( ͡° ͜ʖ ͡°)"))
#+END_SRC
** Remapping out-of-reach commands
On the Kinesis Advantage, some key combinations are painful to reach (at least
on my RSI'd wrists). Translate some of those here.
#+BEGIN_SRC emacs-lisp
  (define-key key-translation-map (kbd "s-h") (kbd "C-h"))
  ; mapping <escape> to 'keyboard-escape-quit doesn't seem to work for some reason, so we just translate
  (define-key key-translation-map (kbd "<escape>") (kbd "C-g"))

  (define-key key-translation-map (kbd "<s-return>") (kbd "<C-return>"))
  (define-key key-translation-map (kbd "<s-S-return>") (kbd "<C-S-return>"))
#+END_SRC

** Getting help
~which-key~ is useful for discovering keybindings I'm not yet used to.
#+BEGIN_SRC emacs-lisp
  (use-package which-key :ensure t
    :config (which-key-mode))
#+END_SRC
* Backup
#+BEGIN_SRC emacs-lisp
  (defvar --backup-directory (concat user-emacs-directory "backups"))

  (if (not (file-exists-p --backup-directory))
      (make-directory --backup-directory t))

  (setq backup-directory-alist `(("." . ,--backup-directory)))
  (setq make-backup-files t               ; backup of a file the first time it is saved.
        backup-by-copying t               ; don't clobber symlinks
        version-control t                 ; version numbers for backup files
        delete-old-versions t             ; delete excess backup files silently
        delete-by-moving-to-trash t
        kept-old-versions 6               ; oldest versions to keep when a new numbered backup is made (default: 2)
        kept-new-versions 9               ; newest versions to keep when a new numbered backup is made (default: 2)
        auto-save-default t               ; auto-save every buffer that visits a file
        auto-save-timeout 20              ; number of seconds idle time before auto-save (default: 30)
        auto-save-interval 200            ; number of keystrokes between auto-saves (default: 300)
        )
    (setq delete-by-moving-to-trash t)

    (setq backup-directory-alist `(("." . ,(expand-file-name
                                            (concat user-emacs-directory "backups")))))

  (global-auto-revert-mode)               ; revert a file’s buffer automatically when it’s been changed on disk
#+END_SRC

* Git
Magit is so awesome, it barely needs any setup at all.
#+BEGIN_SRC emacs-lisp
  (use-package magit
    :bind
    (([f8] . magit-status)
     ("M-s-b" . magit-blame)))
#+END_SRC

Scroll wheel moves through time instead of space ([[https://xkcd.com/1806/][ref.]])
#+BEGIN_SRC emacs-lisp
  (defmacro enable-time-machine-and-call (&rest body)
    `(lambda ()
       (interactive)
       (unless (bound-and-true-p git-timemachine-mode)
         (progn
           (message "Enabling git-timemachine mode")
           (git-timemachine)))
       ,@body))

  (use-package git-timemachine
    :config
    (progn
      (global-set-key (kbd "<M-mouse-5>") (enable-time-machine-and-call (git-timemachine-show-next-revision)))
      (global-set-key (kbd "<M-mouse-4>") (enable-time-machine-and-call (git-timemachine-show-previous-revision)))))
#+END_SRC

* Shell
Based on the excellent config and article from [[https://github.com/howardabrams/dot-files/blob/master/emacs-eshell.org][Howard Abrams]]. Code will mostly
be different as it turns out that most of his config doesn’t really work for me,
but the ideas are pretty darn good.

First of all, we need a convenient way to spawn shells.
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "<f1>") 'eshell)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defun eshell-here ()
    "Opens up a new shell in the directory associated with the
  current buffer's file. The eshell is renamed to match that
  directory to make multiple eshell windows easier."
    (interactive)
    (let* ((parent (if (buffer-file-name)
                       (file-name-directory (buffer-file-name))
                     default-directory))
           (height (/ (window-total-height) 3))
           (name   (car (last (split-string parent "/" t)))))
      (split-window-vertically (- height))
      (other-window 1)
      (eshell "new")
      (rename-buffer (concat "*eshell: " name "*"))

      (insert "ls")
      (eshell-send-input)))

  (global-set-key (kbd "C-!") 'eshell-here)
  (defun eshell/x ()
    (delete-window)
    (eshell/exit))
#+END_SRC

Some executables don’t behave well with Eshell out of the box, so we tweak them a little.
#+BEGIN_SRC emacs-lisp
  (add-hook 'eshell-mode-hook (lambda ()
      (add-to-list 'eshell-visual-commands "ssh")
      (add-to-list 'eshell-visual-commands "tail")))
#+END_SRC

I can’t believe you can start an Eshell session remotely via Tramp.
#+BEGIN_SRC emacs-lisp
  (defun eshell-there (host)
    (interactive "sHost: ")
    (let ((default-directory (format "/%s:" host)))
      (eshell host)))
#+END_SRC

** Aliases
#+BEGIN_SRC emacs-lisp
  (defun eshell/d (&rest args)
    (dired (pop args) "."))
#+END_SRC
** Prompt
First, we need a function to tell us the current git branch.

#+BEGIN_SRC emacs-lisp
  (defun curr-dir-git-branch-string (pwd)
    "Returns current git branch as a string, or the empty string if
  PWD is not in a git repo (or the git command is not found)."
    (interactive)
    (when (and (eshell-search-path "git")
               (locate-dominating-file pwd ".git"))
      (let ((git-output (shell-command-to-string (concat "cd " pwd " && git branch | grep '\\*' | sed -e 's/^\\* //'"))))
        (if (> (length git-output) 0)
            (concat " :" (substring git-output 0 -1))
          "(no branch)"))))
#+END_SRC

The function takes the current directory passed in via =pwd= and
replaces the =$HOME= part with a tilde. I’m sure this function already
exists in the eshell source, but I didn’t find it…

#+BEGIN_SRC emacs-lisp
  (defun pwd-replace-home (pwd)
    "Replace home in PWD with tilde (~) character."
    (interactive)
    (let* ((home (expand-file-name (getenv "HOME")))
           (home-len (length home)))
      (if (and
           (>= (length pwd) home-len)
           (equal home (substring pwd 0 home-len)))
          (concat "~" (substring pwd home-len))
        pwd)))
#+END_SRC

Make the directory name be shorter…by replacing all directory names
with just its first names. However, we leave the last two to be the
full names. Why yes, I did steal this.

#+BEGIN_SRC emacs-lisp
  (defun pwd-shorten-dirs (pwd)
    "Shorten all directory names in PWD except the last two."
    (let ((p-lst (split-string pwd "/")))
      (if (> (length p-lst) 2)
          (concat
           (mapconcat (lambda (elm) (if (zerop (length elm)) ""
                                 (substring elm 0 1)))
                      (butlast p-lst 2)
                      "/")
           "/"
           (mapconcat (lambda (elm) elm)
                      (last p-lst 2)
                      "/"))
        pwd)))  ;; Otherwise, we just return the PWD
#+END_SRC

Break up the directory into a “parent” and a “base”:

#+BEGIN_SRC emacs-lisp
  (defun split-directory-prompt (directory)
    (if (string-match-p ".*/.*" directory)
        (list (file-name-directory directory) (file-name-base directory))
      (list "" directory)))
#+END_SRC

Now tie it all together with a prompt function can color each of the
prompts components and turn off the default one.

#+BEGIN_SRC emacs-lisp
  (setq eshell-prompt-function
        (lambda ()
          (let* ((directory (split-directory-prompt (pwd-shorten-dirs (pwd-replace-home (eshell/pwd)))))
                 (parent (car directory))
                 (name (cadr directory))
                 (branch (or (curr-dir-git-branch-string (eshell/pwd)) "")))

            (if (eq 'dark (frame-parameter nil 'background-mode))
                (concat   ;; Prompt for Dark Themes
                 (propertize parent 'face `(:foreground "#8888FF"))
                 (propertize name   'face `(:foreground "#8888FF" :weight bold))
                 (propertize branch 'face `(:foreground "green"))
                 (propertize " $"   'face `(:weight ultra-bold))
                 (propertize " "    'face `(:weight bold)))

              (concat    ;; Prompt for Light Themes
               (propertize parent 'face `(:foreground "blue"))
               (propertize name   'face `(:foreground "blue" :weight bold))
               (propertize branch 'face `(:foreground "dark green"))
               (propertize " $"   'face `(:weight ultra-bold))
               (propertize " "    'face `(:weight bold)))))))

  (setq eshell-highlight-prompt nil)
#+END_SRC

** Import some variables from the shell
#+BEGIN_SRC emacs-lisp
  (use-package exec-path-from-shell
    :config
    (progn
      (exec-path-from-shell-copy-env "PATH")
      (exec-path-from-shell-copy-env "SSH_AGENT_PID")
      (exec-path-from-shell-copy-env "GOPATH")
      (exec-path-from-shell-copy-env "SSH_AUTH_SOCK")))
#+END_SRC
* Mode-specific
** JavaScript
#+BEGIN_SRC emacs-lisp
  (use-package js2-mode
    :mode ("\\.jsx\\'" "\\.js\\'")
    :bind
    (:map js2-mode-map ("C-c C-c" . js-send-region))
    :config
    (progn
      (setq js2-basic-offset 2
            js2-strict-trailing-comma-warning nil
            js2-global-externs
            '("angular" "d3" "require" "karma" "it" "describe" "beforeEach" "module"))
      (add-hook 'js2-mode-hook 'js2-imenu-extras-mode)
      (define-key js2-mode-map (kbd "M-j") nil)))

  (use-package js2-refactor
    :ensure t
    :bind
    (:map js2-refactor-mode-map
          ("C-k" . js2r-kill)
          ("<M-S-up>" . js2r-move-line-up)
          ("<M-S-down>" . js2r-move-line-down)
          ("s-r" . js2r-rename-var))
    :config
    (progn
      (add-hook 'js2-mode-hook 'js2-refactor-mode)
      (js2r-add-keybindings-with-prefix "C-c C-r")))

  (use-package tide
    :config
    (progn
      (setq tide-completion-detailed t
            tide-completion-enable-autoimport-suggestions t
            tide-always-show-documentation t)

      (defun setup-tide-mode ()
        (tide-setup)
        (eldoc-mode +1)
        (tide-hl-identifier-mode +1))

      (add-hook 'typescript-mode-hook 'setup-tide-mode)
      (add-hook 'js2-mode-hook 'setup-tide-mode)

      (flycheck-add-next-checker 'javascript-eslint 'javascript-tide 'append)))
#+END_SRC
** Common Lisp
Nothing fancy here, just a regular SLIME installation.
#+BEGIN_SRC emacs-lisp
  (use-package slime
    :config
    (progn
      (setq inferior-lisp-program "/usr/bin/sbcl"
            slime-net-coding-system 'utf-8-unix)
      (slime-setup '(slime-fancy))
      (set-language-environment "UTF-8")
      (setenv "LC_LOCALE" "en_US.UTF-8")
      (setenv "LC_CTYPE" "en_US.UTF-8")))
#+END_SRC
** Web
#+BEGIN_SRC emacs-lisp
  (use-package emmet-mode
    :config
    (progn
      (add-hook 'web-mode-hook 'emmet-mode)
      (add-hook 'sgml-mode-hook 'emmet-mode)
      (add-hook 'css-mode-hook emmet-mode)
      (setq emmet-self-closing-tag-style ""
            emmet-indentation 2
            css-mode-indent-offset 2))
    (define-key emmet-mode-keymap (kbd "<C-return>") nil))

  (use-package web-mode
    :mode ("\\.php\\'" "\\.css\\'" "\\.tpl\\’" "\\.less\\'")
    :bind
    (:map web-mode-map
          ("C-M-u" . web-mode-element-parent)
          ("C-M-d" . web-mode-element-child)
          ("C-M-n" . web-mode-element-next)
          ("C-M-p" . web-mode-element-previous))
    :config
    (setq-default web-mode-css-indent-offset 2
                  web-mode-code-indent-offset 2
                  web-mode-markup-indent-offset 2
                  web-mode-attr-indent-offset nil
                  css-indent-offset 2)
    ;; the docs say these have to be defined in a hook
    (add-hook 'web-mode-hook (lambda ()
                               (setq web-mode-enable-css-colorization t
                                     web-mode-enable-current-element-highlight t
                                     web-mode-code-indent-offset 2
                                     js-indent-level 2
                                     web-mode-auto-close-style 1
                                     web-mode-enable-auto-indentation t
                                     web-mode-enable-auto-opening t
                                     web-mode-enable-auto-pairing t
                                     web-mode-enable-auto-quoting t
                                     web-mode-attr-indent-offset nil
                                     web-mode-attr-indent-offset nil)))
    (setq web-mode-ac-sources-alist
          '(("css" . (ac-source-css-property))
            ("html" . (ac-source-words-in-buffer ac-source-abbrev))))
    (add-hook 'web-mode-hook 'turn-off-fci-mode))

  (use-package less-css-mode
    :mode ("\\.less$" . less-css-mode))

  (defun php-tpl-localize (p1 p2)
    "Wrap region in a PHP call to xgettext.
  Called interactively, use the selected region.
  When called from Lisp, use delimiters P1 and P2."
    (interactive "r")
    (save-mark-and-excursion
     (goto-char p1)
     (insert "<?= _('")
     (setq begin (point))
     (forward-char (- p2 p1))
     (setq end (point))
     (insert "') ?>")
     (replace-string "'" "\\'" nil begin end)
     (message "Localized region")))
#+END_SRC
** Dired
Note that you'll need to call ~all-the-icons-install-fonts~ if you don't have the
required fonts installed (likely).

#+BEGIN_SRC emacs-lisp
  (use-package all-the-icons-dired
    :diminish all-the-icons-dired-mode
    :config
    (add-hook 'dired-mode-hook 'all-the-icons-dired-mode))

  (add-hook 'dired-mode-hook 'dired-hide-details-mode)
  (setq dired-dwim-target t)              ; move/copy files across dired buffers
#+END_SRC

** Go
Please note that this configuration requires quite a bit of external tools and
resources. You'll need at least to get the extra tools (~go get -u
golang.org/x/tools/cmd/...~), but there may be more dependencies missing here.

#+BEGIN_SRC emacs-lisp
  (use-package go-mode
    :config
    (setq gofmt-command "goimports")

    (defun go-compile ()
      (interactive)
      (compile "go build"))

    (defun go-test ()
      (interactive)
      (compile "go test"))

    (define-key go-mode-map (kbd "C-\\") 'go-compile)
    (define-key go-mode-map (kbd "M-\\") 'go-test)

    (add-hook 'go-mode-hook (lambda ()
                              (add-hook 'before-save-hook 'gofmt-before-save))))

  (use-package go-eldoc
    :config
    (add-hook 'go-mode-hook 'go-eldoc-setup))

  (use-package company-go
    :config
    (add-hook 'go-mode-hook (lambda ()
                              (set (make-local-variable 'company-backends) '(company-go))
                              (company-mode))))

  (use-package go-guru
    :bind
    (:map go-mode-map
          ("M-." . go-guru-definition)
          ("M-," . pop-tag-mark))
    :config
    (add-hook 'go-mode-hook 'go-guru-hl-identifier-mode))
#+END_SRC
** Org
#+BEGIN_SRC emacs-lisp
  (use-package org
    :bind
    (:map org-mode-map
          ("M-[" . org-set-tags)
          ("C-c s" . org-sort)
          ("<C-up>" . org-up-element)
          ("<C-down>" . org-down-element)
          ("s-t" . org-todo))
    :config
    (progn
      ;; For some reason, declaring these in `:bind` won't work
      (global-set-key (kbd "C-c b") 'org-iswitchb)
      (global-set-key (kbd "C-c j") 'org-clock-goto)
      (global-set-key (kbd "<f2>") 'org-capture)
      (global-set-key (kbd "<f3>") 'org-agenda)
      (global-set-key (kbd "C-c c") 'org-capture)
      (global-set-key (kbd "C-c a") 'org-agenda)

      (define-key org-mode-map (kbd "M-s-i") 'org-clock-in)
      (define-key org-mode-map (kbd "M-s-o") 'org-clock-out)

      ;; run shell commands from org-babel
      (defvar -org-babel-langs '((sh . t) (python . t)))
      (setq org-babel-python-command "python3")
      (org-babel-do-load-languages 'org-babel-load-languages -org-babel-langs)

      ;; display/update images in the buffer after I evaluate
      (add-hook 'org-babel-after-execute-hook 'org-display-inline-images 'append)

      (add-hook 'org-mode-hook 'auto-fill-mode)

      ;; Link to manpages from org
      (org-add-link-type "man" 'org-man-open)
      (add-hook 'org-store-link-functions 'org-man-store-link)

      (defcustom org-man-command 'man
        "The Emacs command to be used to display a man page."
        :group 'org-link
        :type '(choice (const man) (const woman)))

      (defun org-man-open (path)
        "Visit the manpage on PATH.
  PATH should be a topic that can be thrown at the man command."
        (funcall org-man-command path))

      (defun org-man-store-link ()
        "Store a link to a manpage."
        (when (memq major-mode '(Man-mode woman-mode))
          ;; This is a man page, we do make this link
          (let* ((page (org-man-get-page-name))
                 (link (concat "man:" page))
                 (description (format "Manpage for %s" page)))
            (org-store-link-props
             :type "man"
             :link link
             :description description))))

      (defun org-man-get-page-name ()
        "Extract the page name from the buffer name."
        ;; This works for both `Man-mode' and `woman-mode'.
        (if (string-match " \\(\\S-+\\)\\*" (buffer-name))
            (match-string 1 (buffer-name))
          (error "Cannot create link to this man page")))

      (setq org-agenda-include-diary t
            org-log-reschedule 'note
            org-log-done 'time
            org-enforce-todo-dependencies t
            org-enforce-todo-checkbox-dependencies t
            org-fontify-whole-heading-line t
            org-fontify-done-headline t
            org-fontify-quote-and-verse-blocks t
            org-hide-emphasis-markers t
            org-agenda-restore-windows-after-quit t
            org-src-fontify-natively t     ; syntax highlight in code blocks
            org-return-follows-link t      ; return opens links
            org-confirm-babel-evaluate nil ; stop prompting for confirmation on eval
            org-src-tab-acts-natively t    ; make TAB behave as expected in src blocks
            org-support-shift-select nil
            org-refile-targets '((nil :maxlevel . 3)
                                 ("~/Org/work.org" :maxlevel . 1)
                                 ("~/Org/gtd.org" :maxlevel . 3)
                                 ("~/Org/someday.org" :maxlevel . 1)
                                 ("~/Org/tickler.org" :maxlevel . 2))
            org-outline-path-complete-in-steps nil ; Refile in a single go
            org-refile-use-outline-path 'file      ; Refile to top-level
            org-todo-keywords
            '((sequence "TODO(t)" "WAITING(w)" "|" "DONE(d)" "CANCELLED(c)")))))

  (use-package org-pomodoro
    :commands (org-pomodoro)
    :bind ("C-S-p" . org-pomodoro)
    :config
    (setq alert-user-configuration (quote ((((:category . "org-pomodoro")) libnotify nil)))))
#+END_SRC

*** Getting Things Done
This is a new section as I'm experimenting with implementing GTD in org-mode. I'll likely refile it soon.

I want to be able to quickly file new items to my inbox. Let's do so via capture templates.
#+BEGIN_SRC emacs-lisp
  (setq org-capture-templates '(("t" "Todo [inbox]" entry
                                 (file+headline "~/Org/inbox.org" "Inbox")
                                 "* TODO %i%?")
                                ("T" "Tickler" entry
                                 (file+headline "~/Org/tickler.org" "Tickler")
                                 "* %i%? \n %^t")
                                ("j" "Journal entry" entry
                                 (file+datetree "~/Org/journal.org")
                                 "* %?")))
#+END_SRC

What I need now are [[http://orgmode.org/worg/org-tutorials/org-custom-agenda-commands.html][custom agenda commands]] to filter my backlog.
#+BEGIN_SRC emacs-lisp
  (setq org-agenda-custom-commands
        '(("n" "Next actions" alltodo nil
           ((org-agenda-overriding-header "Next actions")
            (org-agenda-skip-function #'my-org-agenda-skip-all-siblings-but-first)))
          ("w" "Next actions (work)" tags-todo "WORK"
           ((org-agenda-overriding-header "Work tasks")
            (org-agenda-skip-function #'my-org-agenda-skip-all-siblings-but-first)))
          ("W" "Waiting for..." todo "WAITING")))

  (defun my-org-agenda-skip-all-siblings-but-first ()
    "Skip all but the first non-done entry."
    (let (should-skip-entry)
      (unless (org-current-is-todo)
        (setq should-skip-entry t))
      (save-excursion
        (while (and (not should-skip-entry) (org-goto-sibling t))
          (when (org-current-is-todo)
            (setq should-skip-entry t))))
      (when should-skip-entry
        (or (outline-next-heading)
            (goto-char (point-max))))))

  (defun org-current-is-todo ()
    (string= "TODO" (org-get-todo-state)))

  (setq org-agenda-files '("~/Org/tickler.org" "~/Org/work.org" "~/Org/gtd.org"))
#+END_SRC
** Other
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "M-p") 'compile)
(global-set-key (kbd "M-P") 'recompile)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("\\.hdl\\'" . vhdl-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package inf-ruby
    :config (add-hook 'ruby-mode-hook 'inf-ruby-minor-mode)
    :bind
    (:map inf-ruby-minor-mode-map
          ("C-c C-c" . ruby-send-buffer)
          ("C-c C-e" . ruby-send-last-sexp)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
    (use-package puppet-mode
      :config
      (setq-default puppet-indent-level 4))
#+END_SRC
** RSS + Pocket
#+BEGIN_SRC emacs-lisp
  (use-package elfeed
    :config
    (setq elfeed-feeds '("https://jvns.ca/atom.xml"
                         "http://blog.ricbit.com/feeds/posts/default"
                         "https://sivers.org/en.atom"
                         "https://wingolog.org/feed/atom"
                         "https://lobste.rs/rss"
                         "https://codewithoutrules.com/atom.xml"
                         "https://blog.jessfraz.com/index.xml"
                         "http://feeds.feedburner.com/zenhabits"
                         "http://lisperator.net/atom"
                         "http://n-gate.com/index.atom"
                         "http://emacsrocks.com/atom.xml"
                         "https://www.destroyallsoftware.com/screencasts/feed"
                         "https://www.masteringemacs.org/feed"
                         ("http://xahlee.info/math/blog.xml" xah-lee)
                         ("http://xahlee.info/js/blog.xml" xah-lee)
                         ("http://xahlee.info/comp/blog.xml" xah-lee))))

  (use-package pocket-reader)
#+END_SRC
* Startup
#+BEGIN_SRC emacs-lisp
  (defun initial-window-setup ()
    "Initially set up split windows and buffers"
    (interactive)
    (org-agenda-list)
    (other-window +1)
    (find-file "~/Org/inbox.org")
    (split-window-below)
    (other-window +1)
    (cd "~")
    (eshell))

  (add-hook 'after-init-hook 'initial-window-setup)
#+END_SRC
* Mail
I'm trying out mu4e, let's see how this goes
#+BEGIN_SRC emacs-lisp
    (add-to-list 'load-path "/usr/share/emacs/site-lisp/mu4e")
    (require 'mu4e)
#+END_SRC
* Custom file
The custom file holds all auto-generated Emacs configs, which I use for Org-mode
quite a lot. This is so my =init.el= doesn't get littered by auto-generated stuff.
#+BEGIN_SRC emacs-lisp
(setq custom-file "~/.emacs.d/custom.el")
(load custom-file :noerror)
#+END_SRC
