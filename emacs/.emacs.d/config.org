#+TITLE: GNU Emacs configuration
#+STARTUP: indent
#+LAYOUT: post
#+OPTIONS: H:5 num:nil tags:nil toc:nil timestamps:t
#+DESCRIPTION: Loading Emacs configuration using org-babel
#+TAGS: emacs

* Who am I
#+BEGIN_SRC emacs-lisp
  (setq user-full-name "Guilherme Goncalves"
        user-email-address "gsg@ggoncalves.me"
        system-time-locale "C")
#+END_SRC
* Window setup
I like to set the appearance as early as possible to avoid glitches in
the loading process. This makes for a cleaner Emacs window.

#+BEGIN_SRC emacs-lisp
  (if (fboundp 'tool-bar-mode) (tool-bar-mode -1))
  (if (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
  (global-hl-line-mode t)
  (fringe-mode 1) ; 1px fringe
  (column-number-mode)
  (blink-cursor-mode 0)
  (tooltip-mode -1)
  (menu-bar-mode -1)
  (setq inhibit-startup-message t
        initial-scratch-message ""
        mode-line-default-help-echo nil
        indicate-buffer-boundaries nil
        indicate-empty-lines nil
        cursor-in-non-selected-windows t
        highlight-nonselected-windows nil
        bidi-display-reordering nil
        blink-matching-paren nil
        help-window-select t)
#+END_SRC

This config file is used across multiple computers and different OSes, which
render fonts quite differently. This might be overkill, but I want to have a
list of options of fonts to render so we don't end up with garbage.

#+BEGIN_SRC emacs-lisp
  (defun load-font-from-options (font-list)
    "Set the default font to the first available from FONT-LIST.
  Given a list of cons cells containing font name and font size,
  call `set-default-font' on the first one that's available"
    (let ((supported-fonts (font-family-list))
          (format-font-name (lambda (font)
                              (destructuring-bind (font-name . font-size) font
                                (concat font-name "-" (number-to-string font-size))))))
      (some (lambda (font) (when (member (car font) supported-fonts)
                             (set-default-font (funcall format-font-name font))
                             t))
            font-list)))
#+END_SRC

* Package setup
#+BEGIN_SRC emacs-lisp
  (require 'package)
  (setq package-archives '(("gnu" . "https://elpa.gnu.org/packages/")
                           ("org" . "http://orgmode.org/elpa/")
                           ("marmalade" . "https://marmalade-repo.org/packages/")
                           ("melpa" . "http://melpa.org/packages/")))
  (package-initialize)

  (unless package-archive-contents
    (package-refresh-contents))

  (unless (package-installed-p 'use-package)
    (package-initialize)
    (package-install 'use-package))

  (setq use-package-always-ensure t)
  (add-to-list 'load-path (concat user-emacs-directory "elisp"))
#+END_SRC

* Look and feel
** Other customizations
This replaces some words with their Math symbols (eg: lambda => λ).
#+BEGIN_SRC emacs-lisp
  (global-prettify-symbols-mode 1)
#+END_SRC

Highlight changes in the gutter
#+BEGIN_SRC emacs-lisp
  (use-package git-gutter
    :init (global-git-gutter-mode +1)
    :config
    (setq git-gutter:update-interval 2)
    (mapc (lambda (pair)
            (set-face-background (car pair) (cdr pair))
            (set-face-foreground (car pair) (cdr pair)))
          '((git-gutter:added . "#8bc34a")
            (git-gutter:modified . "#b39ddb")
            (git-gutter:deleted . "#f36c60")))
    :bind
    (("C-c C-n" . git-gutter:next-hunk)
     ("C-c C-p" . git-gutter:previous-hunk)))
#+END_SRC

Show time and status information on the modeline, so we can go fullscreen and
don't depend on the OS.
#+BEGIN_SRC emacs-lisp
  (setq display-time-default-load-average 0) ; 1-minute load average
  (setq display-time-24hr-format t)
  (display-time-mode)
  (display-battery-mode)
#+END_SRC

*** Highlight TODO entries
#+BEGIN_SRC emacs-lisp
  (use-package hl-todo
    :init (global-hl-todo-mode)
    :bind
    (:map hl-todo-mode-map
          ("C-c <up>" . hl-todo-previous)
          ("C-c <down>" . hl-todo-next)
          ("C-c T" . hl-todo-occur)))
#+END_SRC
*** Miscellaneous
#+BEGIN_SRC emacs-lisp
  ;;; Display rules at column 80
  (setq-default fill-column 80)
  (use-package fill-column-indicator
    :config
    (add-hook 'prog-mode-hook 'fci-mode))

  (show-paren-mode +1)
  (setq async-shell-command-display-buffer nil)
#+END_SRC
*** Pretty modeline
#+BEGIN_SRC emacs-lisp
  (use-package minions :config (minions-mode 1))
#+END_SRC

** Fonts and stuff
Prettier Unicode symbols.
#+BEGIN_SRC emacs-lisp
  (when (member "Symbola" (font-family-list))
    (set-fontset-font t 'unicode "Symbola" nil 'prepend))
#+END_SRC

Ditch monospace fonts if we're reading text.
#+BEGIN_SRC emacs-lisp
  (defun use-variable-width-font ()
    "Set current buffer to use variable-width font."
    (variable-pitch-mode 1)
    (text-scale-increase 1))

  (add-hook 'markdown-mode-hook 'use-variable-width-font)
#+END_SRC

Control font size with the keyboard
#+BEGIN_SRC emacs-lisp
  (defun font-size-reset ()
    "Reset the text-scale to zero."
    (interactive)
    (text-scale-set 0))

  (defvar font-size--increment 0.5
    "The increment value for `font-size-increase' and `font-size-decrease'.")

  (defun font-size-increase ()
    "Increase the text-scale by `font-size--increment'."
    (interactive)
    (text-scale-increase font-size--increment))

  (defun font-size-decrease ()
    "Decrease the text-scale by `font-size--increment'."
    (interactive)
    (text-scale-decrease font-size--increment))

  (global-set-key (kbd "s-0") 'font-size-reset)
  (global-set-key (kbd "s-=") 'font-size-increase)
  (global-set-key (kbd "s--") 'font-size-decrease)
#+END_SRC
* Editing goodies
** Ain't nobody got time for typing "yes"/"no".
#+BEGIN_SRC emacs-lisp
  (defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC
** Interactively do things
#+BEGIN_SRC emacs-lisp
    (use-package rg
      :bind
      ("M-F" . rg-menu))

    (use-package smex
      :bind
      (:map global-map
            ("M-x" . smex)
            ("M-X" . smex-major-mode-commands)))

    (use-package ido-vertical-mode
      :config
      (ido-mode 1)
      (ido-vertical-mode 1)
      (setq ido-vertical-define-keys 'C-n-and-C-p-only
            ido-vertical-show-count t))

    (ido-everywhere t)
    (global-set-key (kbd "C-x C-f") 'find-file)
    (global-set-key (kbd "s-o") 'find-file)
    (global-set-key (kbd "s-b") 'ido-switch-buffer)
    (setq ido-use-filename-at-point 'guess
          ;; fuzzy matching for ido
          ido-enable-flex-matching t
          ido-create-new-buffer 'always
          ido-ignore-extensions t)

    (use-package projectile
      :bind
      (("s-&" . projectile-run-async-shell-command-in-root)
       ("s-!" . projectile-run-eshell)
       ("C-!" . projectile-run-shell-command-in-root)
       ("C-c C-e" . projectile-run-eshell)
       ("C-c C-s" . projectile-run-shell)
       ("C-\\" . projectile-find-file)
       ("s-p" . projectile-find-file))
      :init (projectile-mode)
      :config
      (setq projectile-completion-system 'ido)
      (define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map))

    (use-package counsel-projectile
      :bind ("C-S-f" . counsel-projectile-ag))
#+END_SRC

** Moving around
#+BEGIN_SRC emacs-lisp
  (defun another-window ()
    "Select the previous window in the current frame.  Use `other-window' with an argument -1."
    (interactive)
    (other-window -1))

  (global-set-key (kbd "C-S-w") (lambda () (interactive) (kill-buffer nil)))
  (global-set-key (kbd "s-]") 'other-window)
  (global-set-key (kbd "s-[")  'another-window)

  (global-set-key (kbd "M-4") 'split-window-below)
  (global-set-key (kbd "M-$") 'split-window-right)
  (global-set-key (kbd "M-9") 'delete-window)

  (windmove-default-keybindings 'super)
  (setq windmove-wrap-around t)

  ; no more janky scrolling
  (setq next-line-add-newlines nil
        scroll-margin 10
        scroll-step 1
        scroll-conservatively 100
        scroll-preserve-screen-position 1)

  (use-package undo-tree
    :bind
    (("C-z" . undo-tree-undo)
     ("C-S-z" . undo-tree-redo)
     ("s-z" . undo-tree-undo)
     ("s-S-z" . undo-tree-redo)
     ("s-Z" . undo-tree-redo)
     ("C-x u" . undo-tree-visualize)
     ("<S-mouse-4>" . undo-tree-undo)
     ("<S-mouse-5>" . undo-tree-redo))
    :init
    (global-undo-tree-mode)
    :config
    (setq undo-tree-visualizer-timestamps t
          undo-tree-visualizer-diff t))

  (defun jump-to-scratch ()
    (interactive)
    (switch-to-buffer "*scratch*"))
  (global-set-key (kbd "M--") 'jump-to-scratch)

  (defun edit-config-file ()
    "Edit the Emacs configuration file."
    (interactive)
    (find-file "~/.emacs.d/config.org"))

  (defvar gg-todo-file (expand-file-name "~/TODO")
    "Location of my TODO file.")

  (defun gg-todo ()
    "Open my personal TODO file."
    (interactive)
    (find-file gg-todo-file))
  (global-set-key (kbd "<f4>") 'gg-todo)

  (defun reload-emacs-config ()
    "Reload the Emacs configuration"
    (interactive)
    (load user-init-file))

  (defun back-to-indentation-or-beginning ()
    "Move point to beginning of line, or to first non-space character"
    (interactive)
    (if (= (point) (progn (back-to-indentation) (point)))
        (beginning-of-line)))
  (global-set-key (kbd "<home>") 'back-to-indentation-or-beginning)
  (global-set-key (kbd "C-a") 'back-to-indentation-or-beginning)

  (defun goto-line-with-feedback ()
    "Show line numbers temporarily, while prompting for the line number input"
    (interactive)
    (unwind-protect
        (progn
          (display-line-numbers-mode 1)
          (goto-line (read-number "Goto line: ")))
      (display-line-numbers-mode -1)))
  (global-set-key [remap goto-line] 'goto-line-with-feedback)

  (use-package avy
    :bind
    (("s-j" . avy-goto-char-timer))
    :config
    (define-key isearch-mode-map (kbd "s-j") 'avy-isearch))

  (use-package ace-window
    :bind
    (("C-o" . ace-window))
    :config
    (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l)))

#+END_SRC

** Get rid of useless whitespace
#+BEGIN_SRC emacs-lisp
  (use-package ws-butler
    :config (ws-butler-global-mode))

  (defun cleanup-buffer-safe ()
    "Perform a bunch of safe operations on the whitespace content.
  For a more agressive cleanup that also does indentation, use
  cleanup-buffer."
    (interactive)
    (untabify (point-min) (point-max))
    (set-buffer-file-coding-system 'utf-8))

  (defun cleanup-buffer ()
    "Perform a bunch of operations on the whitespace content of a buffer.
  Including indent-buffer, which should not be called automatically on save."
    (interactive)
    (whitespace-cleanup)
    (cleanup-buffer-safe)
    (indent-region (point-min) (point-max)))

  (global-set-key (kbd "C-c N") 'cleanup-buffer)
  (global-set-key (kbd "C-c n") 'cleanup-buffer-safe)

  (global-set-key (kbd "RET") 'newline-and-indent)

  (setq fill-column 80)
  (setq-default indent-tabs-mode nil)

  ;; Render all whitespace: useful, but crowded
  ;; (setq whitespace-style '(face trailing tabs newline tab-mark space-mark))
  (setq whitespace-style '(face trailing tabs newline))
  (setq whitespace-display-mappings
        '((tab-mark 9 [8594 9])
          (space-mark 32 [183] [46])
          (space-mark 160 [164])
          (newline-mark 10 [8617 10])))

  (add-hook 'prog-mode-hook 'whitespace-mode)
#+END_SRC

** Copy-paste goodness stolen from Xah Lee
#+BEGIN_SRC emacs-lisp
  (defun xah-cut-line-or-region ()
    "Cut current line, or text selection.
  When `universal-argument' is called first, cut whole buffer (respects `narrow-to-region')."
    (interactive)
    (if current-prefix-arg
        (progn ; not using kill-region because we don't want to include previous kill
          (kill-new (buffer-string))
          (delete-region (point-min) (point-max)))
      (progn (if (use-region-p)
                 (kill-region (region-beginning) (region-end) t)
               (kill-whole-line)))))

  (defun xah-copy-line-or-region ()
    "Copy current line, or text selection.
  When called repeatedly, append copy subsequent lines.
  When `universal-argument' is called first, copy whole buffer (respects `narrow-to-region')."
    (interactive)
    (let (-p1 -p2)
      (if current-prefix-arg
          (setq -p1 (point-min) -p2 (point-max))
        (if (use-region-p)
            (setq -p1 (region-beginning) -p2 (region-end))
          (setq -p1 (line-beginning-position) -p2 (line-end-position))))
      (if (eq last-command this-command)
          (progn
            (progn ; hack. exit if there's no more next line
              (end-of-line)
              (forward-char)
              (backward-char))
            (push-mark (point) "NOMSG" "ACTIVATE")
            (kill-append "\n" nil)
            (kill-append (buffer-substring-no-properties (line-beginning-position) (line-end-position)) nil)
            (message "Line copy appended"))
        (progn
          (kill-ring-save -p1 -p2)
          (if current-prefix-arg
              (message "Buffer text copied")
            (message "Text copied"))))
      (end-of-line)
      (forward-char)))

  (global-set-key (kbd "C-w") 'backward-kill-word)
  (global-set-key (kbd "C-x C-k") 'xah-cut-line-or-region)
  (global-set-key (kbd "s-x") 'xah-cut-line-or-region)
  (global-set-key (kbd "M-w") 'xah-copy-line-or-region)
  (global-set-key (kbd "s-c") 'xah-copy-line-or-region)
#+END_SRC

** Manipulate a file directly from its buffer
#+BEGIN_SRC emacs-lisp
  (defun delete-current-buffer-file ()
    "Removes file connected to current buffer and kills buffer."
    (interactive)
    (let ((filename (buffer-file-name))
          (buffer (current-buffer))
          (name (buffer-name)))
      (if (not (and filename (file-exists-p filename)))
          (ido-kill-buffer)
        (when (yes-or-no-p "Are you sure you want to remove this file? ")
          (delete-file filename)
          (kill-buffer buffer)
          (message "File '%s' successfully removed" filename)))))
  (global-set-key (kbd "C-x C-k") 'delete-current-buffer-file)

  (defun rename-current-buffer-file ()
    "Renames current buffer and file it is visiting."
    (interactive)
    (let ((name (buffer-name))
          (filename (buffer-file-name)))
      (if (not (and filename (file-exists-p filename)))
          (error "Buffer '%s' is not visiting a file!" name)
        (let ((new-name (read-file-name "New name: " filename)))
          (if (get-buffer new-name)
              (error "A buffer named '%s' already exists!" new-name)
            (rename-file filename new-name 1)
            (rename-buffer new-name)
            (set-visited-file-name new-name)
            (set-buffer-modified-p nil)
            (message "File '%s' successfully renamed to '%s'"
                     name (file-name-nondirectory new-name)))))))
  (global-set-key (kbd "C-x C-r") 'rename-current-buffer-file)

#+END_SRC

** Open line
#+BEGIN_SRC emacs-lisp
  (defun open-line-below ()
    (interactive)
    (end-of-line)
    (newline)
    (indent-for-tab-command))

  (defun open-line-above ()
    (interactive)
    (beginning-of-line)
    (newline)
    (forward-line -1)
    (indent-for-tab-command))

  (global-set-key (kbd "<S-return>") 'open-line-below)
  (global-set-key (kbd "<C-S-return>") 'open-line-above)
  (global-set-key (kbd "M-j") (lambda () (interactive) (join-line -1)))
  (global-set-key [f7] 'call-last-kbd-macro)
#+END_SRC
** Paredit
#+BEGIN_SRC emacs-lisp
  (use-package paredit
    :config
    (progn
      (define-key paredit-mode-map (kbd "C-j") nil)
      (define-key paredit-mode-map (kbd "RET") 'paredit-newline)
      (define-key lisp-interaction-mode-map (kbd "C-j") 'eval-print-last-sexp)

      (cl-loop for hook in '(emacs-lisp-mode-hook
                             eval-expression-minibuffer-setup-hook
                             ielm-mode-hook lisp-mode-hook
                             lisp-interaction-mode-hook
                             scheme-mode-hook)
               do (add-hook hook #'enable-paredit-mode))))
#+END_SRC

** Autocomplete and snippets
#+BEGIN_SRC emacs-lisp
  (use-package company
    :config
    (progn
      (global-company-mode)
      (setq company-tooltip-align-annotations t
            company-show-numbers t
            company-idle-delay .1
            company-tooltip-idle-delay .1)
      (add-to-list 'completion-styles 'initials t)))

  (use-package company-quickhelp
    :config
    (add-hook 'company-mode-hook 'company-quickhelp-mode))

  (use-package yasnippet
    :config
    (yas-global-mode)
    (add-hook 'prog-mode-hook 'yas-minor-mode))

  (setq-default abbrev-mode t)
  (setq save-abbrevs 'silently)

  (use-package angular-snippets)
  (use-package common-lisp-snippets)
#+END_SRC

** Flycheck + Flymake
All the cool kids seem to be using it.
#+BEGIN_SRC emacs-lisp
  (use-package flycheck)
#+END_SRC

Emacs 26.1 introduced a completely redesigned Flymake mode, which I'm testing now!
#+BEGIN_SRC emacs-lisp
  (add-hook 'prog-mode-hook 'flymake-mode)
#+END_SRC
** Misc editing facilities
I got most of these from the excellent [[http://emacsrocks.com/][Emacs Rocks]].

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C--") 'bury-buffer)
  (global-set-key (kbd "C-;") 'comment-line)
  (electric-pair-mode)
  (add-hook 'prog-mode-hook 'subword-mode)

  (use-package expand-region
    :config (pending-delete-mode t)
    :bind
    (("C-=" . er/expand-region)))

  (use-package multiple-cursors
    :bind
    (("C-S-l" . mc/edit-lines)
     ("C->" . mc/mark-next-like-this)
     ("C-<" . mc/mark-previous-like-this)))

  (defun move-line-down ()
    (interactive)
    (let ((col (current-column)))
      (save-excursion
        (forward-line)
        (transpose-lines 1))
      (forward-line)
      (move-to-column col)))

  (defun move-line-up ()
    (interactive)
    (let ((col (current-column)))
      (save-excursion
        (forward-line)
        (transpose-lines -1))
      (forward-line -2)
      (move-to-column col)))

  (global-set-key (kbd "<M-S-up>") 'move-line-up)
  (global-set-key (kbd "<M-S-down>") 'move-line-down)

  ;; Replace upcase/downcase word with their dwim counterparts
  (global-set-key (kbd "M-u") 'upcase-dwim)
  (global-set-key (kbd "M-l") 'downcase-dwim)
  (global-set-key (kbd "C-x C-u") 'upcase-initials-region)
  (global-set-key (kbd "C-x C-l") nil)

  (global-set-key (kbd "s-r") 'rename-buffer)
#+END_SRC

I run many async commands, and not once have I found the confirmation
"A command is running in the default buffer.  Use a new buffer?" useful.

#+BEGIN_SRC emacs-lisp
  (setq async-shell-command-buffer 'rename-buffer)
#+END_SRC

Unbelievably useful for SQL queries and arrays in code.
#+BEGIN_SRC emacs-lisp
  (defun arrayify (start end quote)
    "Turn strings on newlines into a QUOTEd, comma-separated one-liner."
    (interactive "r\nMQuote: ")
    (let ((insertion
           (mapconcat
            (lambda (x) (format "%s%s%s" quote x quote))
            (split-string (buffer-substring start end)) ", ")))
      (delete-region start end)
      (insert insertion)))
#+END_SRC

*** Silliness
#+BEGIN_SRC emacs-lisp
  ;;; Super important!!
  (defun shrug ()
    "Insert ¯\\_(ツ)_/¯ at point"
    (interactive)
    (insert "¯\\_(ツ)_/¯"))
  (defun lenny ()
    "Insert ( ͡° ͜ʖ ͡°) at point"
    (interactive)
    (insert "( ͡° ͜ʖ ͡°)"))
#+END_SRC
** Remapping out-of-reach commands
#+BEGIN_SRC emacs-lisp
  ; mapping <escape> to 'keyboard-escape-quit doesn't seem to work for some reason, so we just translate
  (define-key key-translation-map (kbd "<escape>") (kbd "C-g"))
  (global-set-key (kbd "s-u") 'revert-buffer)
#+END_SRC

** Getting help
~which-key~ is useful for discovering keybindings I'm not yet used to.
#+BEGIN_SRC emacs-lisp
  (use-package which-key :ensure t
    :config (which-key-mode))
#+END_SRC

~Helpful~ is a better help.
#+BEGIN_SRC emacs-lisp
  (use-package helpful
    :bind
    (("C-h f" . helpful-callable)
     ("C-h v" . helpful-variable)
     ("C-h k" . helpful-key)
     ("C-x C-d" . helpful-at-point)))
#+END_SRC
** Visual search
#+BEGIN_SRC emacs-lisp
  (use-package visual-regexp
    :bind
    (("C-M-%" . vr/replace)))
#+END_SRC
* Backup
#+BEGIN_SRC emacs-lisp
  (defvar --backup-directory (concat user-emacs-directory "backups"))
  (if (not (file-exists-p --backup-directory))
      (make-directory --backup-directory t))

  (setq backup-directory-alist `(("." . ,--backup-directory)))
  (setq make-backup-files t               ; backup of a file the first time it is saved.
        backup-by-copying t               ; don't clobber symlinks
        version-control t                 ; version numbers for backup files
        delete-old-versions t             ; delete excess backup files silently
        delete-by-moving-to-trash t
        trash-directory (expand-file-name "~/.Trash")
        kept-old-versions 6               ; oldest versions to keep when a new numbered backup is made (default: 2)
        kept-new-versions 9               ; newest versions to keep when a new numbered backup is made (default: 2)
        auto-save-default nil             ; don't auto-save every buffer that visits a file
        auto-save-timeout 20              ; number of seconds idle time before auto-save (default: 30)
        auto-save-interval 200            ; number of keystrokes between auto-saves (default: 300)
        )

  (setq backup-directory-alist `(("." . ,(expand-file-name --backup-directory))))

  (global-auto-revert-mode)               ; revert a file’s buffer automatically when it’s been changed on disk
#+END_SRC
* Git
Magit is so awesome, it barely needs any setup at all.
#+BEGIN_SRC emacs-lisp
  (use-package magit
    :bind
    (([f8] . magit-status)
     ("C-x g" . magit-status)
     ("M-s-b" . magit-blame))
    :config
    ;; magit windows should open in the current window
    (add-to-list 'same-window-regexps "^magit: "))
#+END_SRC

Scroll wheel moves through time instead of space ([[https://xkcd.com/1806/][ref.]])
#+BEGIN_SRC emacs-lisp
  (defmacro enable-time-machine-and-call (&rest body)
    `(lambda ()
       (interactive)
       (unless (bound-and-true-p git-timemachine-mode)
         (progn
           (message "Enabling git-timemachine mode")
           (git-timemachine)))
       ,@body))

  (use-package git-timemachine
    :config
    (progn
      (global-set-key (kbd "<M-mouse-5>") (enable-time-machine-and-call (git-timemachine-show-next-revision)))
      (global-set-key (kbd "<M-mouse-4>") (enable-time-machine-and-call (git-timemachine-show-previous-revision)))))
#+END_SRC

* Shell
Based on the excellent config and article from [[https://github.com/howardabrams/dot-files/blob/master/emacs-eshell.org][Howard Abrams]]. Code will mostly
be different as it turns out that most of his config doesn’t really work for me,
but the ideas are pretty darn good.

First of all, we need a convenient way to spawn shells.

#+BEGIN_SRC emacs-lisp
  (defun eshell-here ()
    "Opens up a new shell in the directory associated with the
  current buffer's file. The eshell is renamed to match that
  directory to make multiple eshell windows easier."
    (interactive)
    (let* ((parent (if (buffer-file-name)
                       (file-name-directory (buffer-file-name))
                     default-directory))
           (height (/ (window-total-height) 3))
           (name   (car (last (split-string parent "/" t)))))
      (split-window-vertically (- height))
      (other-window 1)
      (eshell "new")
      (rename-buffer (concat "*eshell: " name "*"))

      (insert "ls")
      (eshell-send-input)))

  (global-set-key (kbd "C-!") 'eshell-here)
  (defun eshell/x ()
    (delete-window)
    (eshell/exit))
#+END_SRC

Some executables don’t behave well with Eshell out of the box, so we tweak them a little.
#+BEGIN_SRC emacs-lisp
  (add-hook 'eshell-mode-hook (lambda ()
                                (add-to-list 'eshell-visual-commands "ssh")
                                (add-to-list 'eshell-visual-commands "tail")))
#+END_SRC

I can’t believe you can start an Eshell session remotely via Tramp.
#+BEGIN_SRC emacs-lisp
  (defun eshell-there (host)
    (interactive "sHost: ")
    (let ((default-directory (format "/%s:" host)))
      (eshell host)))
#+END_SRC

Really clear the buffer.
#+BEGIN_SRC emacs-lisp
  (defun eshell/clear ()
    "Really clear the eshell buffer, including scrollback."
    (let ((eshell-buffer-maximum-lines 0)) (eshell-truncate-buffer)))
#+END_SRC
** Aliases
#+BEGIN_SRC emacs-lisp
  (defun eshell/d (&rest args)
    (dired (pop args) "."))
#+END_SRC
** Prompt
First, we need a function to tell us the current git branch.

#+BEGIN_SRC emacs-lisp
  (defun curr-dir-git-branch-string (pwd)
    "Returns current git branch as a string, or the empty string if
  PWD is not in a git repo (or the git command is not found)."
    (interactive)
    (when (and (eshell-search-path "git")
               (locate-dominating-file pwd ".git"))
      (let ((git-output (shell-command-to-string (concat "cd " pwd "; git branch | grep '\\*' | sed -e 's/^\\* //'"))))
        (if (> (length git-output) 0)
            (concat " :" (substring git-output 0 -1))
          "(no branch)"))))
#+END_SRC

The function takes the current directory passed in via =pwd= and
replaces the =$HOME= part with a tilde. I’m sure this function already
exists in the eshell source, but I didn’t find it…

#+BEGIN_SRC emacs-lisp
  (defun pwd-replace-home (pwd)
    "Replace home in PWD with tilde (~) character."
    (interactive)
    (let* ((home (expand-file-name (getenv "HOME")))
           (home-len (length home)))
      (if (and
           (>= (length pwd) home-len)
           (equal home (substring pwd 0 home-len)))
          (concat "~" (substring pwd home-len))
        pwd)))
#+END_SRC

Make the directory name be shorter…by replacing all directory names
with just its first names. However, we leave the last two to be the
full names. Why yes, I did steal this.

#+BEGIN_SRC emacs-lisp
  (defun pwd-shorten-dirs (pwd)
    "Shorten all directory names in PWD except the last two."
    (let ((p-lst (split-string pwd "/")))
      (if (> (length p-lst) 2)
          (concat
           (mapconcat (lambda (elm) (if (zerop (length elm)) ""
                                      (substring elm 0 1)))
                      (butlast p-lst 2)
                      "/")
           "/"
           (mapconcat (lambda (elm) elm)
                      (last p-lst 2)
                      "/"))
        pwd)))  ;; Otherwise, we just return the PWD
#+END_SRC

Break up the directory into a “parent” and a “base”:

#+BEGIN_SRC emacs-lisp
  (defun split-directory-prompt (directory)
    (if (string-match-p ".*/.*" directory)
        (list (file-name-directory directory) (file-name-base directory))
      (list "" directory)))
#+END_SRC

Now tie it all together with a prompt function can color each of the
prompts components and turn off the default one.

#+BEGIN_SRC emacs-lisp
  (setq eshell-prompt-function
        (lambda ()
          (let* ((directory (split-directory-prompt (pwd-shorten-dirs (pwd-replace-home (eshell/pwd)))))
                 (parent (car directory))
                 (name (cadr directory))
                 (branch (or (curr-dir-git-branch-string (eshell/pwd)) "")))

            (if (eq 'dark (frame-parameter nil 'background-mode))
                (concat   ;; Prompt for Dark Themes
                 (propertize parent 'face `(:foreground "#8888FF"))
                 (propertize name   'face `(:foreground "#8888FF" :weight bold))
                 (propertize branch 'face `(:foreground "green"))
                 (propertize " $"   'face `(:weight ultra-bold))
                 (propertize " "    'face `(:weight bold)))

              (concat    ;; Prompt for Light Themes
               (propertize parent 'face `(:foreground "blue"))
               (propertize name   'face `(:foreground "blue" :weight bold))
               (propertize branch 'face `(:foreground "dark green"))
               (propertize " $"   'face `(:weight ultra-bold))
               (propertize " "    'face `(:weight bold)))))))

  (setq eshell-highlight-prompt nil)
#+END_SRC

** Import some variables from the shell
#+BEGIN_SRC emacs-lisp
  (use-package exec-path-from-shell
    :config
    (progn
      (exec-path-from-shell-copy-env "PATH")
      (exec-path-from-shell-copy-env "SSH_AGENT_PID")
      (exec-path-from-shell-copy-env "GOPATH")
      (exec-path-from-shell-copy-env "SSH_AUTH_SOCK")))
#+END_SRC
** Aweshell
#+BEGIN_SRC emacs-lisp
  (require 'aweshell)

  (defun gg-next-aweshell (arg)
    "Switch to next aweshell.  If called with `ARG', create a new one."
    (interactive "P")
    (let ((open-new? (and arg t)))
      (if open-new? (aweshell-new) (aweshell-next))))

  (global-set-key (kbd "<f12>") 'aweshell-dedicated-toggle)
  (global-set-key (kbd "<f1>") 'gg-next-aweshell)
#+END_SRC
** Multi-term

* Mode-specific
** JavaScript
#+BEGIN_SRC emacs-lisp
  (use-package js2-mode
    :mode "\\.jsx?\\'"
    :bind
    (:map js2-mode-map
          ("C-c C-c" . js-send-region)
          ("M-." . js2-jump-to-definition)
          ("M-," . pop-tag-mark))
    :config
    (setq js2-basic-offset 2
          js2-strict-trailing-comma-warning nil)
    (add-hook 'js2-mode-hook 'js2-imenu-extras-mode)
    (define-key js2-mode-map (kbd "M-j") nil))

  (use-package js2-refactor
    :bind
    (:map js2-refactor-mode-map
          ("C-k" . js2r-kill)
          ("<M-S-up>" . js2r-move-line-up)
          ("<M-S-down>" . js2r-move-line-down)
          ("s-r" . js2r-rename-var))
    :init
    (defun setup-js2r-mode ()
      (js2-refactor-mode +1)
      (js2r-add-keybindings-with-prefix "C-c C-r"))
    (add-hook 'js2-mode-hook 'setup-js2r-mode))

  (use-package typescript-mode
    :mode "\\.js\\'"
    :config
    (setq typescript-indent-level 2))

  (use-package prettier-js
    :config
    (progn
      (add-hook 'tide-mode-hook 'prettier-js-mode)))

  (use-package tide
    :bind
    (:map tide-mode-map
          ("C-c r" . tide-rename-symbol)
          ("C-c C-r" . tide-rename-file)
          ("M-?" . tide-references))
    :config
    (progn
      (setq tide-completion-detailed t
            tide-completion-enable-autoimport-suggestions t
            tide-always-show-documentation t)
      (flycheck-add-next-checker 'javascript-eslint 'javascript-tide 'append))
    :init
    (progn
      (defun setup-tide-mode ()
        (tide-setup)
        (eldoc-mode +1)
        (tide-hl-identifier-mode +1)
        (setq-local company-backend 'tide-company))

      (add-hook 'typescript-mode-hook 'setup-tide-mode)
      (add-hook 'js2-mode-hook 'setup-tide-mode)))

  (use-package mocha
    :bind
    (:map tide-mode-map
          ("<C-s-268632082>" . mocha-test-definition-nodes)))
#+END_SRC
*** TODO node + ~npm~ utilities
#+BEGIN_SRC emacs-lisp
  (defun node-repl ()
    "Start a NodeJS REPL in comint mode."
    (interactive)
    (setenv "NODE_NO_READLINE" "1") ; avoid fancy terminal codes
    (pop-to-buffer (make-comint "node-repl" "node" nil "--interactive")))
#+END_SRC
#+BEGIN_SRC emacs-lisp
  (defun run-npm-script (script-name)
    "Execute npm run SCRIPT_NAME. If we're in a projectile dir, run it there."
    (interactive "bScript name: ")
    (projectile-run-async-shell-command-in-root (concat "npm run " script-name)))
#+END_SRC
** Common Lisp
Nothing fancy here, just a regular +SLIME+ Sly installation.
#+BEGIN_SRC emacs-lisp
  (use-package sly
    :config
    (progn
      (setq inferior-lisp-program "/usr/local/bin/sbcl"
            slime-net-coding-system 'utf-8-unix)
      (set-language-environment "UTF-8")
      (setenv "LC_LOCALE" "en_US.UTF-8")
      (setenv "LC_CTYPE" "en_US.UTF-8")))
#+END_SRC
** Web
#+BEGIN_SRC emacs-lisp
  (use-package emmet-mode
    :config
    (progn
      (add-hook 'web-mode-hook 'emmet-mode)
      (add-hook 'sgml-mode-hook 'emmet-mode)
      (add-hook 'css-mode-hook emmet-mode)
      (setq emmet-self-closing-tag-style ""
            emmet-indentation 2
            css-mode-indent-offset 2))
    (define-key emmet-mode-keymap (kbd "<C-return>") nil))

  (use-package web-mode
    :mode ("\\.html\\'" "\\.tsx\\'" "\\.jsx\\'" "\\.php\\'" "\\.css\\'" "\\.tpl\\'" "\\.less\\'")
    :bind
    (:map web-mode-map
          ("C-M-u" . web-mode-element-parent)
          ("C-M-d" . web-mode-element-child)
          ("C-M-n" . web-mode-element-next)
          ("C-M-p" . web-mode-element-previous))
    :config
    (setq-default web-mode-css-indent-offset 2
                  web-mode-code-indent-offset 2
                  web-mode-markup-indent-offset 2
                  web-mode-attr-indent-offset nil
                  css-indent-offset 2)
    ;; the docs say these have to be defined in a hook
    (add-hook 'web-mode-hook (lambda ()
                               (setq web-mode-enable-css-colorization t
                                     web-mode-enable-current-element-highlight t
                                     web-mode-code-indent-offset 2
                                     js-indent-level 2
                                     web-mode-auto-close-style 1
                                     web-mode-enable-auto-indentation t
                                     web-mode-enable-auto-opening t
                                     web-mode-enable-auto-pairing t
                                     web-mode-enable-auto-quoting t
                                     web-mode-attr-indent-offset nil
                                     web-mode-attr-indent-offset nil)

                               (when (string-equal "tsx" (file-name-extension buffer-file-name))
                                 (setup-tide-mode))

                               (when (string-equal "jsx" (file-name-extension buffer-file-name))
                                 (js2-mode +1))))
    (flycheck-add-mode 'typescript-tslint 'web-mode)
    (flycheck-add-mode 'typescript-tslint 'tide-mode)
    (setq web-mode-ac-sources-alist
          '(("css" . (ac-source-css-property))
            ("html" . (ac-source-words-in-buffer ac-source-abbrev))))
    (add-hook 'web-mode-hook 'turn-off-fci-mode))

  (use-package less-css-mode
    :mode ("\\.less$" . less-css-mode))

  (use-package graphql-mode)
#+END_SRC
** Dired
Note that you'll need to call ~all-the-icons-install-fonts~ if you don't have the
required fonts installed (likely).

#+BEGIN_SRC emacs-lisp
  (use-package all-the-icons-dired
    :config
    (add-hook 'dired-mode-hook 'all-the-icons-dired-mode))

  (add-hook 'dired-mode-hook 'dired-hide-details-mode)
  (setq dired-dwim-target t)              ; move/copy files across dired buffers
#+END_SRC

** Go
Please note that this configuration requires quite a bit of external tools and
resources. You'll need at least to get the extra tools (~go get -u
golang.org/x/tools/cmd/...~), but there may be more dependencies missing here.

#+BEGIN_SRC emacs-lisp
  (use-package go-mode
    :config
    (setq gofmt-command "goimports")

    (defun go-compile ()
      (interactive)
      (compile "go build"))

    (defun go-test ()
      (interactive)
      (compile "go test"))

    (define-key go-mode-map (kbd "C-\\") 'go-compile)
    (define-key go-mode-map (kbd "M-\\") 'go-test)

    (add-hook 'go-mode-hook (lambda ()
                              (add-hook 'before-save-hook 'gofmt-before-save))))

  (use-package go-eldoc
    :config
    (add-hook 'go-mode-hook 'go-eldoc-setup))

  (use-package company-go
    :config
    (add-hook 'go-mode-hook (lambda ()
                              (set (make-local-variable 'company-backends) '(company-go))
                              (company-mode))))

  (use-package go-guru
    :bind
    (:map go-mode-map
          ("M-." . go-guru-definition)
          ("M-," . pop-tag-mark))
    :config
    (add-hook 'go-mode-hook 'go-guru-hl-identifier-mode))
#+END_SRC
** Org
First off, to export to HTML, we need ~htmlize~.
#+BEGIN_SRC emacs-lisp
  (use-package htmlize)
#+END_SRC

Now, we begin configuring ~org~.
#+BEGIN_SRC emacs-lisp
  (use-package org
    :bind
    (:map org-mode-map
          ("M-[" . org-set-tags)
          ("C-c s" . org-sort)
          ("<C-up>" . org-up-element)
          ("<C-down>" . org-down-element)
          ("s-t" . org-todo))
    :config
    (progn
      ;; For some reason, declaring these in `:bind` won't work
      ;; XXX these commands are global and shouldn't really be under C-c therefore
      (global-set-key (kbd "C-c l") 'org-store-link)
      (global-set-key (kbd "C-c b") 'org-switchb)
      (global-set-key (kbd "C-c j") 'org-clock-goto)
      (global-set-key (kbd "<f2>") 'org-capture)
      (global-set-key (kbd "<f3>") 'org-agenda)
      (global-set-key (kbd "C-c c") 'org-capture)
      (global-set-key (kbd "C-c a") 'org-agenda)

      (define-key org-mode-map (kbd "M-s-i") 'org-clock-in)
      (define-key org-mode-map (kbd "M-s-o") 'org-clock-out)

      ;; run shell commands from org-babel
      (defvar -org-babel-langs '((shell . t) (python . t)))
      (setq org-babel-python-command "python3")
      (org-babel-do-load-languages 'org-babel-load-languages -org-babel-langs)

      ;; display/update images in the buffer after I evaluate
      (add-hook 'org-babel-after-execute-hook 'org-display-inline-images 'append)

      (add-hook 'org-mode-hook 'auto-fill-mode)

      ;; Link to manpages from org
      (org-add-link-type "man" 'org-man-open)
      (add-hook 'org-store-link-functions 'org-man-store-link)

      (defcustom org-man-command 'man
        "The Emacs command to be used to display a man page."
        :group 'org-link
        :type '(choice (const man) (const woman)))

      (defun org-man-open (path)
        "Visit the manpage on PATH.
  PATH should be a topic that can be thrown at the man command."
        (funcall org-man-command path))

      (defun org-man-store-link ()
        "Store a link to a manpage."
        (when (memq major-mode '(Man-mode woman-mode))
          ;; This is a man page, we do make this link
          (let* ((page (org-man-get-page-name))
                 (link (concat "man:" page))
                 (description (format "Manpage for %s" page)))
            (org-store-link-props
             :type "man"
             :link link
             :description description))))

      (defun org-man-get-page-name ()
        "Extract the page name from the buffer name."
        ;; This works for both `Man-mode' and `woman-mode'.
        (if (string-match " \\(\\S-+\\)\\*" (buffer-name))
            (match-string 1 (buffer-name))
          (error "Cannot create link to this man page")))

      (setq org-agenda-include-diary t
            org-log-reschedule 'note
            org-log-done 'time
            org-enforce-todo-dependencies t
            org-enforce-todo-checkbox-dependencies t
            org-fontify-whole-heading-line t
            org-fontify-done-headline t
            org-fontify-quote-and-verse-blocks t
            org-hide-emphasis-markers t
            org-agenda-restore-windows-after-quit t
            org-src-fontify-natively t     ; syntax highlight in code blocks
            org-return-follows-link t      ; return opens links
            org-confirm-babel-evaluate nil ; stop prompting for confirmation on eval
            org-src-tab-acts-natively t    ; make TAB behave as expected in src blocks
            org-support-shift-select nil
            org-image-actual-width nil
            org-html-doctype "html5"
            org-startup-folded nil
            org-refile-targets '((nil :maxlevel . 3)
                                 ("~/sync/Notes/work.org" :maxlevel . 1)
                                 ("~/sync/Notes/personal.org" :maxlevel . 3)
                                 ("~/sync/Notes/someday.org" :maxlevel . 1)
                                 ("~/sync/Notes/tickler.org" :maxlevel . 2))
            org-outline-path-complete-in-steps nil ; Refile in a single go
            org-refile-use-outline-path 'file      ; Refile to top-level
            org-todo-keywords
            '((sequence "TODO(t)" "WAITING(w)" "|" "DONE(d)" "CANCELLED(c)")))))
#+END_SRC

** HTTP and REST
Incredibly useful stuff.
#+BEGIN_SRC emacs-lisp
  (use-package restclient)
  (use-package company-restclient)
#+END_SRC
** Python
Out-of-the-box Python support for emacs seems remarkably good, at least for my
(admittedly limited these days) purposes. In any case, I stole most of these
snippets from [[https://vxlabs.com/2018/06/08/python-language-server-with-emacs-and-lsp-mode/][this article from vxlabs]]. Please note that this requires
~python-language-server~ to be installed:

#+BEGIN_SRC sh
  cd ~/Code/python-project
  pipenv install python-language-server[all]
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package lsp-ui
    :config
    (setq lsp-ui-sideline-ignore-duplicate t)
    (add-hook 'lsp-mode-hook 'lsp-ui-mode))

  (use-package company-lsp
    :config
    (push 'company-lsp company-backends))
#+END_SRC
** SQL
Note that the following depends on ~beautify-sql~:
#+BEGIN_SRC shell :exports source
  sudo gem install anbt-sql-formatter
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defun sql-beautify-region (beg end)
    "Beautify SQL in region between beg and END."
    (interactive "r")
    (save-excursion
      (shell-command-on-region beg end "beautify-sql" nil t)))

  (defun sql-beautify-buffer ()
    "Beautify SQL in buffer."
    (interactive)
    (sql-beautify-region (point-min) (point-max)))
#+END_SRC
** Other
Compile
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "M-\\") 'compile)
  (global-set-key (kbd "C-\\") 'recompile)

  (require 'ansi-color)
  (defun colorize-compilation-buffer ()
    (toggle-read-only)
    (ansi-color-apply-on-region compilation-filter-start (point))
    (toggle-read-only))
  (add-hook 'compilation-filter-hook 'colorize-compilation-buffer)
  (setq compilation-scroll-output t)
#+END_SRC

groovy-mode For ~Jenkinsfiles:~ :/
#+BEGIN_SRC emacs-lisp
  (use-package groovy-mode
    :config
    (add-to-list 'auto-mode-alist '("Jenkinsfile\\'" . groovy-mode)))
#+END_SRC
** Docker stuff
#+BEGIN_SRC emacs-lisp
  (use-package dockerfile-mode)
#+END_SRC

* OSX-specific
If we're on MacOS, enable the menu bar (hiding it won't save any space anyway)
and the fancy transparent window titlebar.
#+BEGIN_SRC emacs-lisp
  (when (string-equal system-type "darwin")
    (progn
      (menu-bar-mode +1)
      (add-to-list 'default-frame-alist '(ns-transparent-titlebar . t))
      ;(add-to-list 'default-frame-alist '(ns-appearance . dark))
      (setq ns-use-proxy-icon  nil)
      (setq frame-title-format nil)
      (setq locate-command "mdfind")))
#+END_SRC

* Startup
#+BEGIN_SRC emacs-lisp
  (defun initial-window-setup ()
    "Initially set up split windows and buffers"
    (interactive)
    (toggle-frame-fullscreen))

  (add-hook 'after-init-hook 'initial-window-setup)
#+END_SRC

* Custom file
The custom file holds all auto-generated Emacs configs, which I use for Org-mode
quite a lot. This is so my =init.el= doesn't get littered by auto-generated stuff.
#+BEGIN_SRC emacs-lisp
  (setq custom-file "~/.emacs.d/custom.el")
  (load custom-file :noerror)
#+END_SRC
* Temp stuff
#+BEGIN_SRC emacs-lisp
  (defun has-special-buffer (window)
    "Return non-nil if WINDOW contains a buffer matching `special-display-regexps'."
    (let ((name (buffer-name(window-buffer window))))
      (some (lambda (regexp) (string-match-p regexp name)) special-display-regexps)))

  (defun display-special-buffer (buf list-of-what)
    "put the special buffers in the right spot (top-left)"
    (let ((target-window (window-at 0 0))
          (pop-up-windows t))
      (if (has-special-buffer target-window)
          (let ((second-window (window-at 0 (- (frame-height) 10))))
            (message (buffer-name (window-buffer second-window)))
            (set-window-buffer second-window (window-buffer target-window))))
      (set-window-buffer target-window buf)
      target-window))

  (setq special-display-regexps
        '("^\\*Async Shell Command\\*\\(<[0-9]+>\\)?$"
          "^\\*webpack\\*$"
          "^\\*server\\*$"
          "^\\*Completions\\*$"
          "^\\*Help\\*$"
          "^\\*grep\\*$"
          "^\\*Apropos\\*$"
          "^\\*elisp macroexpansion\\*$"
          "^\\*local variables\\*$"
          "^\\*Compile-Log\\*$"
          "^\\*Quail Completions\\*$"
          "^\\*Occur\\*$"
          "^\\*frequencies\\*$"
          "^\\*compilation\\*$"
          "^\\*Locate\\*$"
          "^\\*Colors\\*$"
          "^\\*tumme-display-image\\*$"
          "^\\*SLIME Description\\*$"
          "^\\*.* output\\*$"             ; tex compilation buffer
          "^\\*TeX Help\\*$"
          "^\\*Shell Command Output\\*$"
          "^\\*Backtrace\\*$"
          "^\\*helpful .*\\*$"
          "^\\*tide-.*\\*$"
          "^TODO$"))
  (setq special-display-function 'display-special-buffer)

  (global-set-key (kbd "C-x C-b") 'ibuffer)

  (global-unset-key (kbd "s-t"))
  (desktop-save-mode)
#+END_SRC

** Making new buffers and windows
#+BEGIN_SRC emacs-lisp
  (defvar gg-scratch-buffer-mode 'org-mode
    "Major mode to be used in temporary buffers.")

  (defun make-new-buffer-or-frame (arg)
    (interactive "P")
    (let ((make-frame? (and arg t)))
      (if make-frame? (make-frame-command)
        (progn
          (switch-to-buffer (generate-new-buffer "*New*"))
          (funcall gg-scratch-buffer-mode)))))

  (global-set-key (kbd "s-n") 'make-new-buffer-or-frame)
#+END_SRC
** Auto saving
#+BEGIN_SRC emacs-lisp
  (defun xah-save-all-unsaved ()
    "Save all unsaved files. no ask.
  Version 2019-11-05"
    (interactive)
    (save-some-buffers t ))

  ;; when switching out of emacs, all unsaved files will be saved
  (add-hook 'focus-out-hook 'xah-save-all-unsaved)
#+END_SRC
** Windower
cf. [[file:elisp/windower.el][windower.el]].
#+BEGIN_SRC emacs-lisp
  (require 'windower)
  (global-set-key (kbd "<M-tab>") 'windower-switch-to-last-buffer)
  (global-set-key (kbd "M-1") 'windower-toggle-single)
  (global-set-key (kbd "s-|") 'windower-toggle-split)

  (global-set-key (kbd "<s-M-left>") 'windower-move-border-left)
  (global-set-key (kbd "<s-M-down>") 'windower-move-border-below)
  (global-set-key (kbd "<s-M-up>") 'windower-move-border-above)
  (global-set-key (kbd "<s-M-right>") 'windower-move-border-right)

  (global-set-key (kbd "<s-S-left>") 'windower-swap-left)
  (global-set-key (kbd "<s-S-down>") 'windower-swap-below)
  (global-set-key (kbd "<s-S-up>") 'windower-swap-above)
  (global-set-key (kbd "<s-S-right>") 'windower-swap-right)
#+END_SRC

** Deft
#+BEGIN_SRC emacs-lisp
  (use-package deft
    :bind
    (([f3] . deft))
    :config
    (setq deft-extensions '("org" "md" "txt")
          deft-default-extension "org"
          deft-directory "~/sync/Notes"
          deft-new-file-format "%Y%m%d%H%M"))
#+END_SRC
