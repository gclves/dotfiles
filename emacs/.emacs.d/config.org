#+TITLE: GNU Emacs configuration
#+STARTUP: indent
#+LAYOUT: post
#+OPTIONS: H:5 num:nil tags:nil toc:nil timestamps:t
#+DESCRIPTION: Loading Emacs configuration using org-babel
#+TAGS: emacs

* Who am I
#+BEGIN_SRC emacs-lisp
  (setq user-full-name "Guilherme Goncalves"
        user-email-address "gsg@ggoncalves.me"
        system-time-locale "C")
#+END_SRC
* Window setup
I like to set the appearance as early as possible to avoid glitches in
the loading process. This makes for a cleaner Emacs window.

#+BEGIN_SRC emacs-lisp
  (if (fboundp 'tool-bar-mode) (tool-bar-mode -1))
  (if (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
  (global-hl-line-mode t)
  (fringe-mode 1) ; 1px fringe
  (column-number-mode)
  (blink-cursor-mode 0)
  (tooltip-mode -1)
  (menu-bar-mode -1)
  (setq inhibit-startup-message t
        initial-scratch-message ""
        mode-line-default-help-echo nil
        indicate-buffer-boundaries nil
        indicate-empty-lines nil
        cursor-in-non-selected-windows t
        highlight-nonselected-windows nil
        bidi-display-reordering nil
        blink-matching-paren nil
        help-window-select t)
#+END_SRC

This config file is used across multiple computers and different OSes, which
render fonts quite differently. This might be overkill, but I want to have a
list of options of fonts to render so we don't end up with garbage.

#+BEGIN_SRC emacs-lisp
  (defun load-font-from-options (font-list)
    "Set the default font to the first available from FONT-LIST.
  Given a list of cons cells containing font name and font size,
  call `set-default-font' on the first one that's available"
    (let ((supported-fonts (font-family-list))
          (format-font-name (lambda (font)
                              (destructuring-bind (font-name . font-size) font
                                (concat font-name "-" (number-to-string font-size))))))
      (some (lambda (font) (when (member (car font) supported-fonts)
                             (set-default-font (funcall format-font-name font))
                             t))
            font-list)))
#+END_SRC

* Package setup
#+BEGIN_SRC emacs-lisp
  (require 'package)
  (setq package-archives '(("gnu" . "https://elpa.gnu.org/packages/")
                           ("org" . "http://orgmode.org/elpa/")
                           ("marmalade" . "https://marmalade-repo.org/packages/")
                           ("melpa" . "http://melpa.org/packages/")))
  (package-initialize)

  (unless package-archive-contents
    (package-refresh-contents))

  (unless (package-installed-p 'use-package)
    (package-initialize)
    (package-install 'use-package))

  (setq use-package-always-ensure t)
  (add-to-list 'load-path (concat user-emacs-directory "elisp"))
#+END_SRC

* Look and feel
** Other customizations
This replaces some words with their Math symbols (eg: lambda => Î»).
#+BEGIN_SRC emacs-lisp
  (global-prettify-symbols-mode 1)
#+END_SRC

Highlight changes in the gutter
#+BEGIN_SRC emacs-lisp
  (use-package git-gutter
    :init (global-git-gutter-mode +1)
    :config
    (setq git-gutter:update-interval 2)
    (mapc (lambda (pair)
            (set-face-background (car pair) (cdr pair))
            (set-face-foreground (car pair) (cdr pair)))
          '((git-gutter:added . "#8bc34a")
            (git-gutter:modified . "#b39ddb")
            (git-gutter:deleted . "#f36c60")))
    :bind
    (("C-c C-n" . git-gutter:next-hunk)
     ("C-c C-p" . git-gutter:previous-hunk)))
#+END_SRC

Show time and status information on the modeline, so we can go fullscreen and
don't depend on the OS.
#+BEGIN_SRC emacs-lisp
  (setq display-time-default-load-average 0) ; 1-minute load average
  (setq display-time-24hr-format t)
  (display-time-mode)
  (display-battery-mode)
#+END_SRC

*** Highlight TODO entries
#+BEGIN_SRC emacs-lisp
  (use-package hl-todo
    :init (global-hl-todo-mode)
    :bind
    (:map hl-todo-mode-map
          ("C-c <up>" . hl-todo-previous)
          ("C-c <down>" . hl-todo-next)
          ("C-c T" . hl-todo-occur)))
#+END_SRC
*** Miscellaneous
#+BEGIN_SRC emacs-lisp
  ;;; Display rules at column 80
  (setq-default fill-column 80)
  (use-package fill-column-indicator
    :config
    (add-hook 'prog-mode-hook 'fci-mode))

  (show-paren-mode +1)
  (setq async-shell-command-display-buffer nil)
#+END_SRC
*** Pretty modeline
#+BEGIN_SRC emacs-lisp
  (use-package minions :config (minions-mode 1))
#+END_SRC

** Fonts and stuff
Prettier Unicode symbols.
#+BEGIN_SRC emacs-lisp
  (when (member "Symbola" (font-family-list))
    (set-fontset-font t 'unicode "Symbola" nil 'prepend))
#+END_SRC

Ditch monospace fonts if we're reading text.
#+BEGIN_SRC emacs-lisp
  (defun use-variable-width-font ()
    "Set current buffer to use variable-width font."
    (variable-pitch-mode 1)
    (text-scale-increase 1))

  (add-hook 'markdown-mode-hook 'use-variable-width-font)
#+END_SRC

Control font size with the keyboard
#+BEGIN_SRC emacs-lisp
  (defun font-size-reset ()
    "Reset the text-scale to zero."
    (interactive)
    (text-scale-set 0))

  (defvar font-size--increment 0.5
    "The increment value for `font-size-increase' and `font-size-decrease'.")

  (defun font-size-increase ()
    "Increase the text-scale by `font-size--increment'."
    (interactive)
    (text-scale-increase font-size--increment))

  (defun font-size-decrease ()
    "Decrease the text-scale by `font-size--increment'."
    (interactive)
    (text-scale-decrease font-size--increment))

  (global-set-key (kbd "s-0") 'font-size-reset)
  (global-set-key (kbd "s-=") 'font-size-increase)
  (global-set-key (kbd "s--") 'font-size-decrease)
#+END_SRC
* Editing goodies
** Ain't nobody got time for typing "yes"/"no".
#+BEGIN_SRC emacs-lisp
  (defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC
** Interactively do things
#+BEGIN_SRC emacs-lisp
    (use-package rg
      :bind
      ("M-F" . rg-menu))

    (use-package smex
      :bind
      (:map global-map
            ("M-x" . smex)
            ("M-X" . smex-major-mode-commands)))

    (use-package ido-vertical-mode
      :config
      (ido-mode 1)
      (ido-vertical-mode 1)
      (setq ido-vertical-define-keys 'C-n-and-C-p-only
            ido-vertical-show-count t))

    (ido-everywhere t)
    (global-set-key (kbd "C-x C-f") 'find-file)
    (global-set-key (kbd "s-o") 'find-file)
    (global-set-key (kbd "s-b") 'ido-switch-buffer)
    (setq ido-use-filename-at-point 'guess
          ;; fuzzy matching for ido
          ido-enable-flex-matching t
          ido-create-new-buffer 'always
          ido-ignore-extensions t)

    (use-package projectile
      :bind
      (("s-&" . projectile-run-async-shell-command-in-root)
       ("s-!" . projectile-run-eshell)
       ("C-!" . projectile-run-shell-command-in-root)
       ("C-c C-e" . projectile-run-eshell)
       ("C-c C-s" . projectile-run-shell)
       ("C-\\" . projectile-find-file)
       ("s-p" . projectile-find-file))
      :init (projectile-mode)
      :config
      (setq projectile-completion-system 'ido)
      (define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map))

    (use-package counsel-projectile
      :bind ("C-S-f" . counsel-projectile-ag))
#+END_SRC

** Moving around
#+BEGIN_SRC emacs-lisp
  (defun another-window ()
    "Select the previous window in the current frame.  Use `other-window' with an argument -1."
    (interactive)
    (other-window -1))

  (global-set-key (kbd "C-S-w") (lambda () (interactive) (kill-buffer nil)))
  (global-set-key (kbd "s-]") 'other-window)
  (global-set-key (kbd "s-[")  'another-window)

  (global-set-key (kbd "M-4") 'split-window-below)
  (global-set-key (kbd "M-$") 'split-window-right)
  (global-set-key (kbd "M-9") 'delete-window)

  (windmove-default-keybindings 'super)
  (setq windmove-wrap-around t)

  ; no more janky scrolling
  (setq next-line-add-newlines nil
        scroll-margin 10
        scroll-step 1
        scroll-conservatively 100
        scroll-preserve-screen-position 1)

  (use-package undo-tree
    :bind
    (("C-z" . undo-tree-undo)
     ("C-S-z" . undo-tree-redo)
     ("s-z" . undo-tree-undo)
     ("s-S-z" . undo-tree-redo)
     ("s-Z" . undo-tree-redo)
     ("C-x u" . undo-tree-visualize)
     ("<S-mouse-4>" . undo-tree-undo)
     ("<S-mouse-5>" . undo-tree-redo))
    :init
    (global-undo-tree-mode)
    :config
    (setq undo-tree-visualizer-timestamps t
          undo-tree-visualizer-diff t))

  (defun jump-to-scratch ()
    (interactive)
    (switch-to-buffer "*scratch*"))
  (global-set-key (kbd "M--") 'jump-to-scratch)

  (defun edit-config-file ()
    "Edit the Emacs configuration file."
    (interactive)
    (find-file "~/.emacs.d/config.org"))

  (defvar gg-todo-file (expand-file-name "~/TODO")
    "Location of my TODO file.")

  (defun gg-todo ()
    "Open my personal TODO file."
    (interactive)
    (find-file gg-todo-file))
  (global-set-key (kbd "<f4>") 'gg-todo)

  (defun reload-emacs-config ()
    "Reload the Emacs configuration"
    (interactive)
    (load user-init-file))

  (defun back-to-indentation-or-beginning ()
    "Move point to beginning of line, or to first non-space character"
    (interactive)
    (if (= (point) (progn (back-to-indentation) (point)))
        (beginning-of-line)))
  (global-set-key (kbd "<home>") 'back-to-indentation-or-beginning)
  (global-set-key (kbd "C-a") 'back-to-indentation-or-beginning)

  (defun goto-line-with-feedback ()
    "Show line numbers temporarily, while prompting for the line number input"
    (interactive)
    (unwind-protect
        (progn
          (display-line-numbers-mode 1)
          (goto-line (read-number "Goto line: ")))
      (display-line-numbers-mode -1)))
  (global-set-key [remap goto-line] 'goto-line-with-feedback)

  (use-package avy
    :bind
    (("s-j" . avy-goto-char-timer))
    :config
    (define-key isearch-mode-map (kbd "s-j") 'avy-isearch))

  (use-package ace-window
    :bind
    (("C-o" . ace-window))
    :config
    (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l)))

#+END_SRC

** Get rid of useless whitespace
#+BEGIN_SRC emacs-lisp
  (use-package ws-butler
    :config (ws-butler-global-mode))

  (defun cleanup-buffer-safe ()
    "Perform a bunch of safe operations on the whitespace content.
  For a more agressive cleanup that also does indentation, use
  cleanup-buffer."
    (interactive)
    (untabify (point-min) (point-max))
    (set-buffer-file-coding-system 'utf-8))

  (defun cleanup-buffer ()
    "Perform a bunch of operations on the whitespace content of a buffer.
  Including indent-buffer, which should not be called automatically on save."
    (interactive)
    (whitespace-cleanup)
    (cleanup-buffer-safe)
    (indent-region (point-min) (point-max)))

  (global-set-key (kbd "C-c N") 'cleanup-buffer)
  (global-set-key (kbd "C-c n") 'cleanup-buffer-safe)

  (global-set-key (kbd "RET") 'newline-and-indent)

  (setq fill-column 80)
  (setq-default indent-tabs-mode nil)

  ;; Render all whitespace: useful, but crowded
  ;; (setq whitespace-style '(face trailing tabs newline tab-mark space-mark))
  (setq whitespace-style '(face trailing tabs newline))
  (setq whitespace-display-mappings
        '((tab-mark 9 [8594 9])
          (space-mark 32 [183] [46])
          (space-mark 160 [164])
          (newline-mark 10 [8617 10])))

  (add-hook 'prog-mode-hook 'whitespace-mode)
#+END_SRC

** Copy-paste goodness stolen from Xah Lee
#+BEGIN_SRC emacs-lisp
  (defun xah-cut-line-or-region ()
    "Cut current line, or text selection.
  When `universal-argument' is called first, cut whole buffer (respects `narrow-to-region')."
    (interactive)
    (if current-prefix-arg
        (progn ; not using kill-region because we don't want to include previous kill
          (kill-new (buffer-string))
          (delete-region (point-min) (point-max)))
      (progn (if (use-region-p)
                 (kill-region (region-beginning) (region-end) t)
               (kill-whole-line)))))

  (defun xah-copy-line-or-region ()
    "Copy current line, or text selection.
  When called repeatedly, append copy subsequent lines.
  When `universal-argument' is called first, copy whole buffer (respects `narrow-to-region')."
    (interactive)
    (let (-p1 -p2)
      (if current-prefix-arg
          (setq -p1 (point-min) -p2 (point-max))
        (if (use-region-p)
            (setq -p1 (region-beginning) -p2 (region-end))
          (setq -p1 (line-beginning-position) -p2 (line-end-position))))
      (if (eq last-command this-command)
          (progn
            (progn ; hack. exit if there's no more next line
              (end-of-line)
              (forward-char)
              (backward-char))
            (push-mark (point) "NOMSG" "ACTIVATE")
            (kill-append "\n" nil)
            (kill-append (buffer-substring-no-properties (line-beginning-position) (line-end-position)) nil)
            (message "Line copy appended"))
        (progn
          (kill-ring-save -p1 -p2)
          (if current-prefix-arg
              (message "Buffer text copied")
            (message "Text copied"))))
      (end-of-line)
      (forward-char)))

  (global-set-key (kbd "C-w") 'backward-kill-word)
  (global-set-key (kbd "C-x C-k") 'xah-cut-line-or-region)
  (global-set-key (kbd "s-x") 'xah-cut-line-or-region)
  (global-set-key (kbd "M-w") 'xah-copy-line-or-region)
  (global-set-key (kbd "s-c") 'xah-copy-line-or-region)
#+END_SRC

** Manipulate a file directly from its buffer
#+BEGIN_SRC emacs-lisp
  (defun delete-current-buffer-file ()
    "Removes file connected to current buffer and kills buffer."
    (interactive)
    (let ((filename (buffer-file-name))
          (buffer (current-buffer))
          (name (buffer-name)))
      (if (not (and filename (file-exists-p filename)))
          (ido-kill-buffer)
        (when (yes-or-no-p "Are you sure you want to remove this file? ")
          (delete-file filename)
          (kill-buffer buffer)
          (message "File '%s' successfully removed" filename)))))
  (global-set-key (kbd "C-x C-k") 'delete-current-buffer-file)

  (defun rename-current-buffer-file ()
    "Renames current buffer and file it is visiting."
    (interactive)
    (let ((name (buffer-name))
          (filename (buffer-file-name)))
      (if (not (and filename (file-exists-p filename)))
          (error "Buffer '%s' is not visiting a file!" name)
        (let ((new-name (read-file-name "New name: " filename)))
          (if (get-buffer new-name)
              (error "A buffer named '%s' already exists!" new-name)
            (rename-file filename new-name 1)
            (rename-buffer new-name)
            (set-visited-file-name new-name)
            (set-buffer-modified-p nil)
            (message "File '%s' successfully renamed to '%s'"
                     name (file-name-nondirectory new-name)))))))
  (global-set-key (kbd "C-x C-r") 'rename-current-buffer-file)

#+END_SRC

** Open line
#+BEGIN_SRC emacs-lisp
  (defun open-line-below ()
    (interactive)
    (end-of-line)
    (newline)
    (indent-for-tab-command))

  (defun open-line-above ()
    (interactive)
    (beginning-of-line)
    (newline)
    (forward-line -1)
    (indent-for-tab-command))

  (global-set-key (kbd "<S-return>") 'open-line-below)
  (global-set-key (kbd "<C-S-return>") 'open-line-above)
  (global-set-key (kbd "M-j") (lambda () (interactive) (join-line -1)))
  (global-set-key [f7] 'call-last-kbd-macro)
#+END_SRC
** Paredit
#+BEGIN_SRC emacs-lisp
  (use-package paredit
    :config
    (progn
      (define-key paredit-mode-map (kbd "C-j") nil)
      (define-key paredit-mode-map (kbd "RET") 'paredit-newline)
      (define-key lisp-interaction-mode-map (kbd "C-j") 'eval-print-last-sexp)

      (cl-loop for hook in '(emacs-lisp-mode-hook
                             eval-expression-minibuffer-setup-hook
                             ielm-mode-hook lisp-mode-hook
                             lisp-interaction-mode-hook
                             scheme-mode-hook)
               do (add-hook hook #'enable-paredit-mode))))
#+END_SRC

** Autocomplete and snippets
#+BEGIN_SRC emacs-lisp
  (use-package company
    :config
    (progn
      (global-company-mode)
      (setq company-tooltip-align-annotations t
            company-show-numbers t
            company-idle-delay .1
            company-tooltip-idle-delay .1)
      (add-to-list 'completion-styles 'initials t)))

  (use-package company-quickhelp
    :config
    (add-hook 'company-mode-hook 'company-quickhelp-mode))

  (use-package yasnippet
    :config
    (yas-global-mode)
    (add-hook 'prog-mode-hook 'yas-minor-mode))

  (setq-default abbrev-mode t)
  (setq save-abbrevs 'silently)

  (use-package angular-snippets)
  (use-package common-lisp-snippets)
#+END_SRC

** Flycheck + Flymake
All the cool kids seem to be using it.
#+BEGIN_SRC emacs-lisp
  (use-package flycheck)
#+END_SRC

Emacs 26.1 introduced a completely redesigned Flymake mode, which I'm testing now!
#+BEGIN_SRC emacs-lisp
  (add-hook 'prog-mode-hook 'flymake-mode)
#+END_SRC
** Misc editing facilities
I got most of these from the excellent [[http://emacsrocks.com/][Emacs Rocks]].

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C--") 'bury-buffer)
  (global-set-key (kbd "C-;") 'comment-line)
  (electric-pair-mode)
  (add-hook 'prog-mode-hook 'subword-mode)

  (use-package expand-region
    :config (pending-delete-mode t)
    :bind
    (("C-=" . er/expand-region)))

  (use-package multiple-cursors
    :bind
    (("C-S-l" . mc/edit-lines)
     ("C->" . mc/mark-next-like-this)
     ("C-<" . mc/mark-previous-like-this)))

  (defun move-line-down ()
    (interactive)
    (let ((col (current-column)))
      (save-excursion
        (forward-line)
        (transpose-lines 1))
      (forward-line)
      (move-to-column col)))

  (defun move-line-up ()
    (interactive)
    (let ((col (current-column)))
      (save-excursion
        (forward-line)
        (transpose-lines -1))
      (forward-line -2)
      (move-to-column col)))

  (global-set-key (kbd "<M-S-up>") 'move-line-up)
  (global-set-key (kbd "<M-S-down>") 'move-line-down)

  ;; Replace upcase/downcase word with their dwim counterparts
  (global-set-key (kbd "M-u") 'upcase-dwim)
  (global-set-key (kbd "M-l") 'downcase-dwim)
  (global-set-key (kbd "C-x C-u") 'upcase-initials-region)
  (global-set-key (kbd "C-x C-l") nil)

  (global-set-key (kbd "s-r") 'rename-buffer)
#+END_SRC

I run many async commands, and not once have I found the confirmation
"A command is running in the default buffer.  Use a new buffer?" useful.

#+BEGIN_SRC emacs-lisp
  (setq async-shell-command-buffer 'rename-buffer)
#+END_SRC

Unbelievably useful for SQL queries and arrays in code.
#+BEGIN_SRC emacs-lisp
  (defun arrayify (start end quote)
    "Turn strings on newlines into a QUOTEd, comma-separated one-liner."
    (interactive "r\nMQuote: ")
    (let ((insertion
           (mapconcat
            (lambda (x) (format "%s%s%s" quote x quote))
            (split-string (buffer-substring start end)) ", ")))
      (delete-region start end)
      (insert insertion)))
#+END_SRC

*** Silliness
#+BEGIN_SRC emacs-lisp
  ;;; Super important!!
  (defun shrug ()
    "Insert Â¯\\_(ã)_/Â¯ at point"
    (interactive)
    (insert "Â¯\\_(ã)_/Â¯"))
  (defun lenny ()
    "Insert ( Í¡Â° ÍÊ Í¡Â°) at point"
    (interactive)
    (insert "( Í¡Â° ÍÊ Í¡Â°)"))
#+END_SRC
** Remapping out-of-reach commands
#+BEGIN_SRC emacs-lisp
  ; mapping <escape> to 'keyboard-escape-quit doesn't seem to work for some reason, so we just translate
  (define-key key-translation-map (kbd "<escape>") (kbd "C-g"))
  (global-set-key (kbd "s-u") 'revert-buffer)
#+END_SRC

** Getting help
~which-key~ is useful for discovering keybindings I'm not yet used to.
#+BEGIN_SRC emacs-lisp
  (use-package which-key :ensure t
    :config (which-key-mode))
#+END_SRC

~Helpful~ is a better help.
#+BEGIN_SRC emacs-lisp
  (use-package helpful
    :bind
    (("C-h f" . helpful-callable)
     ("C-h v" . helpful-variable)
     ("C-h k" . helpful-key)
     ("C-x C-d" . helpful-at-point)))
#+END_SRC
** Visual search
#+BEGIN_SRC emacs-lisp
  (use-package visual-regexp
    :bind
    (("C-M-%" . vr/replace)))
#+END_SRC
* Backup
#+BEGIN_SRC emacs-lisp
  (defvar --backup-directory (concat user-emacs-directory "backups"))
  (if (not (file-exists-p --backup-directory))
      (make-directory --backup-directory t))

  (setq backup-directory-alist `(("." . ,--backup-directory)))
  (setq make-backup-files t               ; backup of a file the first time it is saved.
        backup-by-copying t               ; don't clobber symlinks
        version-control t                 ; version numbers for backup files
        delete-old-versions t             ; delete excess backup files silently
        delete-by-moving-to-trash t
        trash-directory (expand-file-name "~/.Trash")
        kept-old-versions 6               ; oldest versions to keep when a new numbered backup is made (default: 2)
        kept-new-versions 9               ; newest versions to keep when a new numbered backup is made (default: 2)
        auto-save-default nil             ; don't auto-save every buffer that visits a file
        auto-save-timeout 20              ; number of seconds idle time before auto-save (default: 30)
        auto-save-interval 200            ; number of keystrokes between auto-saves (default: 300)
        )

  (setq backup-directory-alist `(("." . ,(expand-file-name --backup-directory))))

  (global-auto-revert-mode)               ; revert a fileâs buffer automatically when itâs been changed on disk
#+END_SRC
* Git
Magit is so awesome, it barely needs any setup at all.
#+BEGIN_SRC emacs-lisp
  (use-package magit
    :bind
    (([f8] . magit-status)
     ("C-x g" . magit-status)
     ("M-s-b" . magit-blame))
    :config
    ;; magit windows should open in the current window
    (add-to-list 'same-window-regexps "^magit: "))
#+END_SRC

Scroll wheel moves through time instead of space ([[https://xkcd.com/1806/][ref.]])
#+BEGIN_SRC emacs-lisp
  (defmacro enable-time-machine-and-call (&rest body)
    `(lambda ()
       (interactive)
       (unless (bound-and-true-p git-timemachine-mode)
         (progn
           (message "Enabling git-timemachine mode")
           (git-timemachine)))
       ,@body))

  (use-package git-timemachine
    :config
    (progn
      (global-set-key (kbd "<M-mouse-5>") (enable-time-machine-and-call (git-timemachine-show-next-revision)))
      (global-set-key (kbd "<M-mouse-4>") (enable-time-machine-and-call (git-timemachine-show-previous-revision)))))
#+END_SRC

* Shell
Based on the excellent config and article from [[https://github.com/howardabrams/dot-files/blob/master/emacs-eshell.org][Howard Abrams]]. Code will mostly
be different as it turns out that most of his config doesnât really work for me,
but the ideas are pretty darn good.

First of all, we need a convenient way to spawn shells.

#+BEGIN_SRC emacs-lisp
  (defun eshell-here ()
    "Opens up a new shell in the directory associated with the
  current buffer's file. The eshell is renamed to match that
  directory to make multiple eshell windows easier."
    (interactive)
    (let* ((parent (if (buffer-file-name)
                       (file-name-directory (buffer-file-name))
                     default-directory))
           (height (/ (window-total-height) 3))
           (name   (car (last (split-string parent "/" t)))))
      (split-window-vertically (- height))
      (other-window 1)
      (eshell "new")
      (rename-buffer (concat "*eshell: " name "*"))

      (insert "ls")
      (eshell-send-input)))

  (global-set-key (kbd "C-!") 'eshell-here)
  (defun eshell/x ()
    (delete-window)
    (eshell/exit))
#+END_SRC

Some executables donât behave well with Eshell out of the box, so we tweak them a little.
#+BEGIN_SRC emacs-lisp
  (add-hook 'eshell-mode-hook (lambda ()
                                (add-to-list 'eshell-visual-commands "ssh")
                                (add-to-list 'eshell-visual-commands "tail")))
#+END_SRC

I canât believe you can start an Eshell session remotely via Tramp.
#+BEGIN_SRC emacs-lisp
  (defun eshell-there (host)
    (interactive "sHost: ")
    (let ((default-directory (format "/%s:" host)))
      (eshell host)))
#+END_SRC

Really clear the buffer.
#+BEGIN_SRC emacs-lisp
  (defun eshell/clear ()
    "Really clear the eshell buffer, including scrollback."
    (let ((eshell-buffer-maximum-lines 0)) (eshell-truncate-buffer)))
#+END_SRC
** Aliases
#+BEGIN_SRC emacs-lisp
  (defun eshell/d (&rest args)
    (dired (pop args) "."))
#+END_SRC
** Prompt
First, we need a function to tell us the current git branch.

#+BEGIN_SRC emacs-lisp
  (defun curr-dir-git-branch-string (pwd)
    "Returns current git branch as a string, or the empty string if
  PWD is not in a git repo (or the git command is not found)."
    (interactive)
    (when (and (eshell-search-path "git")
               (locate-dominating-file pwd ".git"))
      (let ((git-output (shell-command-to-string (concat "cd " pwd "; git branch | grep '\\*' | sed -e 's/^\\* //'"))))
        (if (> (length git-output) 0)
            (concat " :" (substring git-output 0 -1))
          "(no branch)"))))
#+END_SRC

The function takes the current directory passed in via =pwd= and
replaces the =$HOME= part with a tilde. Iâm sure this function already
exists in the eshell source, but I didnât find itâ¦

#+BEGIN_SRC emacs-lisp
  (defun pwd-replace-home (pwd)
    "Replace home in PWD with tilde (~) character."
    (interactive)
    (let* ((home (expand-file-name (getenv "HOME")))
           (home-len (length home)))
      (if (and
           (>= (length pwd) home-len)
           (equal home (substring pwd 0 home-len)))
          (concat "~" (substring pwd home-len))
        pwd)))
#+END_SRC

Make the directory name be shorterâ¦by replacing all directory names
with just its first names. However, we leave the last two to be the
full names. Why yes, I did steal this.

#+BEGIN_SRC emacs-lisp
  (defun pwd-shorten-dirs (pwd)
    "Shorten all directory names in PWD except the last two."
    (let ((p-lst (split-string pwd "/")))
      (if (> (length p-lst) 2)
          (concat
           (mapconcat (lambda (elm) (if (zerop (length elm)) ""
                                      (substring elm 0 1)))
                      (butlast p-lst 2)
                      "/")
           "/"
           (mapconcat (lambda (elm) elm)
                      (last p-lst 2)
                      "/"))
        pwd)))  ;; Otherwise, we just return the PWD
#+END_SRC

Break up the directory into a âparentâ and a âbaseâ:

#+BEGIN_SRC emacs-lisp
  (defun split-directory-prompt (directory)
    (if (string-match-p ".*/.*" directory)
        (list (file-name-directory directory) (file-name-base directory))
      (list "" directory)))
#+END_SRC

Now tie it all together with a prompt function can color each of the
prompts components and turn off the default one.

#+BEGIN_SRC emacs-lisp
  (setq eshell-prompt-function
        (lambda ()
          (let* ((directory (split-directory-prompt (pwd-shorten-dirs (pwd-replace-home (eshell/pwd)))))
                 (parent (car directory))
                 (name (cadr directory))
                 (branch (or (curr-dir-git-branch-string (eshell/pwd)) "")))

            (if (eq 'dark (frame-parameter nil 'background-mode))
                (concat   ;; Prompt for Dark Themes
                 (propertize parent 'face `(:foreground "#8888FF"))
                 (propertize name   'face `(:foreground "#8888FF" :weight bold))
                 (propertize branch 'face `(:foreground "green"))
                 (propertize " $"   'face `(:weight ultra-bold))
                 (propertize " "    'face `(:weight bold)))

              (concat    ;; Prompt for Light Themes
               (propertize parent 'face `(:foreground "blue"))
               (propertize name   'face `(:foreground "blue" :weight bold))
               (propertize branch 'face `(:foreground "dark green"))
               (propertize " $"   'face `(:weight ultra-bold))
               (propertize " "    'face `(:weight bold)))))))

  (setq eshell-highlight-prompt nil)
#+END_SRC

** Import some variables from the shell
#+BEGIN_SRC emacs-lisp
  (use-package exec-path-from-shell
    :config
    (progn
      (exec-path-from-shell-copy-env "PATH")
      (exec-path-from-shell-copy-env "SSH_AGENT_PID")
      (exec-path-from-shell-copy-env "GOPATH")
      (exec-path-from-shell-copy-env "SSH_AUTH_SOCK")))
#+END_SRC
** Aweshell
#+BEGIN_SRC emacs-lisp
  (require 'aweshell)

  (defun gg-next-aweshell (arg)
    "Switch to next aweshell.  If called with `ARG', create a new one."
    (interactive "P")
    (let ((open-new? (and arg t)))
      (if open-new? (aweshell-new) (aweshell-next))))

  (global-set-key (kbd "<f12>") 'aweshell-dedicated-toggle)
  (global-set-key (kbd "<f1>") 'gg-next-aweshell)
#+END_SRC
** Multi-term

* Mode-specific
** JavaScript
#+BEGIN_SRC emacs-lisp
  (use-package js2-mode
    :mode "\\.jsx?\\'"
    :bind
    (:map js2-mode-map
          ("C-c C-c" . js-send-region)
          ("M-." . js2-jump-to-definition)
          ("M-," . pop-tag-mark))
    :config
    (setq js2-basic-offset 2
          js2-strict-trailing-comma-warning nil)
    (add-hook 'js2-mode-hook 'js2-imenu-extras-mode)
    (define-key js2-mode-map (kbd "M-j") nil))

  (use-package js2-refactor
    :bind
    (:map js2-refactor-mode-map
          ("C-k" . js2r-kill)
          ("<M-S-up>" . js2r-move-line-up)
          ("<M-S-down>" . js2r-move-line-down)
          ("s-r" . js2r-rename-var))
    :init
    (defun setup-js2r-mode ()
      (js2-refactor-mode +1)
      (js2r-add-keybindings-with-prefix "C-c C-r"))
    (add-hook 'js2-mode-hook 'setup-js2r-mode))

  (use-package typescript-mode
    :mode "\\.js\\'"
    :config
    (setq typescript-indent-level 2))

  (use-package prettier-js
    :config
    (progn
      (add-hook 'tide-mode-hook 'prettier-js-mode)))

  (use-package tide
    :bind
    (:map tide-mode-map
          ("C-c r" . tide-rename-symbol)
          ("C-c C-r" . tide-rename-file)
          ("M-?" . tide-references))
    :config
    (progn
      (setq tide-completion-detailed t
            tide-completion-enable-autoimport-suggestions t
            tide-always-show-documentation t)
      (flycheck-add-next-checker 'javascript-eslint 'javascript-tide 'append))
    :init
    (progn
      (defun setup-tide-mode ()
        (tide-setup)
        (eldoc-mode +1)
        (tide-hl-identifier-mode +1)
        (setq-local company-backend 'tide-company))

      (add-hook 'typescript-mode-hook 'setup-tide-mode)
      (add-hook 'js2-mode-hook 'setup-tide-mode)))

  (use-package mocha
    :bind
    (:map tide-mode-map
          ("<C-s-268632082>" . mocha-test-definition-nodes)))
#+END_SRC
*** TODO node + ~npm~ utilities
#+BEGIN_SRC emacs-lisp
  (defun node-repl ()
    "Start a NodeJS REPL in comint mode."
    (interactive)
    (setenv "NODE_NO_READLINE" "1") ; avoid fancy terminal codes
    (pop-to-buffer (make-comint "node-repl" "node" nil "--interactive")))
#+END_SRC
#+BEGIN_SRC emacs-lisp
  (defun run-npm-script (script-name)
    "Execute npm run SCRIPT_NAME. If we're in a projectile dir, run it there."
    (interactive "bScript name: ")
    (projectile-run-async-shell-command-in-root (concat "npm run " script-name)))
#+END_SRC
** Common Lisp
Nothing fancy here, just a regular +SLIME+ Sly installation.
#+BEGIN_SRC emacs-lisp
  (use-package sly
    :config
    (progn
      (setq inferior-lisp-program "/usr/local/bin/sbcl"
            slime-net-coding-system 'utf-8-unix)
      (set-language-environment "UTF-8")
      (setenv "LC_LOCALE" "en_US.UTF-8")
      (setenv "LC_CTYPE" "en_US.UTF-8")))
#+END_SRC
** Web
#+BEGIN_SRC emacs-lisp
  (use-package emmet-mode
    :config
    (progn
      (add-hook 'web-mode-hook 'emmet-mode)
      (add-hook 'sgml-mode-hook 'emmet-mode)
      (add-hook 'css-mode-hook emmet-mode)
      (setq emmet-self-closing-tag-style ""
            emmet-indentation 2
            css-mode-indent-offset 2))
    (define-key emmet-mode-keymap (kbd "<C-return>") nil))

  (use-package web-mode
    :mode ("\\.html\\'" "\\.tsx\\'" "\\.jsx\\'" "\\.php\\'" "\\.css\\'" "\\.tpl\\'" "\\.less\\'")
    :bind
    (:map web-mode-map
          ("C-M-u" . web-mode-element-parent)
          ("C-M-d" . web-mode-element-child)
          ("C-M-n" . web-mode-element-next)
          ("C-M-p" . web-mode-element-previous))
    :config
    (setq-default web-mode-css-indent-offset 2
                  web-mode-code-indent-offset 2
                  web-mode-markup-indent-offset 2
                  web-mode-attr-indent-offset nil
                  css-indent-offset 2)
    ;; the docs say these have to be defined in a hook
    (add-hook 'web-mode-hook (lambda ()
                               (setq web-mode-enable-css-colorization t
                                     web-mode-enable-current-element-highlight t
                                     web-mode-code-indent-offset 2
                                     js-indent-level 2
                                     web-mode-auto-close-style 1
                                     web-mode-enable-auto-indentation t
                                     web-mode-enable-auto-opening t
                                     web-mode-enable-auto-pairing t
                                     web-mode-enable-auto-quoting t
                                     web-mode-attr-indent-offset nil
                                     web-mode-attr-indent-offset nil)

                               (when (string-equal "tsx" (file-name-extension buffer-file-name))
                                 (setup-tide-mode))

                               (when (string-equal "jsx" (file-name-extension buffer-file-name))
                                 (js2-mode +1))))
    (flycheck-add-mode 'typescript-tslint 'web-mode)
    (flycheck-add-mode 'typescript-tslint 'tide-mode)
    (setq web-mode-ac-sources-alist
          '(("css" . (ac-source-css-property))
            ("html" . (ac-source-words-in-buffer ac-source-abbrev))))
    (add-hook 'web-mode-hook 'turn-off-fci-mode))

  (use-package less-css-mode
    :mode ("\\.less$" . less-css-mode))

  (use-package graphql-mode)
#+END_SRC
** Dired
Note that you'll need to call ~all-the-icons-install-fonts~ if you don't have the
required fonts installed (likely).

#+BEGIN_SRC emacs-lisp
  (use-package all-the-icons-dired
    :config
    (add-hook 'dired-mode-hook 'all-the-icons-dired-mode))

  (add-hook 'dired-mode-hook 'dired-hide-details-mode)
  (setq dired-dwim-target t)              ; move/copy files across dired buffers
#+END_SRC

** Go
Please note that this configuration requires quite a bit of external tools and
resources. You'll need at least to get the extra tools (~go get -u
golang.org/x/tools/cmd/...~), but there may be more dependencies missing here.

#+BEGIN_SRC emacs-lisp
  (use-package go-mode
    :config
    (setq gofmt-command "goimports")

    (defun go-compile ()
      (interactive)
      (compile "go build"))

    (defun go-test ()
      (interactive)
      (compile "go test"))

    (define-key go-mode-map (kbd "C-\\") 'go-compile)
    (define-key go-mode-map (kbd "M-\\") 'go-test)

    (add-hook 'go-mode-hook (lambda ()
                              (add-hook 'before-save-hook 'gofmt-before-save))))

  (use-package go-eldoc
    :config
    (add-hook 'go-mode-hook 'go-eldoc-setup))

  (use-package company-go
    :config
    (add-hook 'go-mode-hook (lambda ()
                              (set (make-local-variable 'company-backends) '(company-go))
                              (company-mode))))

  (use-package go-guru
    :bind
    (:map go-mode-map
          ("M-." . go-guru-definition)
          ("M-," . pop-tag-mark))
    :config
    (add-hook 'go-mode-hook 'go-guru-hl-identifier-mode))
#+END_SRC
** Org
First off, to export to HTML, we need ~htmlize~.
#+BEGIN_SRC emacs-lisp
  (use-package htmlize)
#+END_SRC

Now, we begin configuring ~org~.
#+BEGIN_SRC emacs-lisp
  (use-package org
    :bind
    (:map org-mode-map
          ("M-[" . org-set-tags)
          ("C-c s" . org-sort)
          ("<C-up>" . org-up-element)
          ("<C-down>" . org-down-element)
          ("s-t" . org-todo))
    :config
    (progn
      ;; For some reason, declaring these in `:bind` won't work
      ;; XXX these commands are global and shouldn't really be under C-c therefore
      (global-set-key (kbd "C-c l") 'org-store-link)
      (global-set-key (kbd "C-c b") 'org-switchb)
      (global-set-key (kbd "C-c j") 'org-clock-goto)
      (global-set-key (kbd "<f2>") 'org-capture)
      (global-set-key (kbd "<f3>") 'org-agenda)
      (global-set-key (kbd "C-c c") 'org-capture)
      (global-set-key (kbd "C-c a") 'org-agenda)

      (define-key org-mode-map (kbd "M-s-i") 'org-clock-in)
      (define-key org-mode-map (kbd "M-s-o") 'org-clock-out)

      ;; run shell commands from org-babel
      (defvar -org-babel-langs '((shell . t) (python . t)))
      (setq org-babel-python-command "python3")
      (org-babel-do-load-languages 'org-babel-load-languages -org-babel-langs)

      ;; display/update images in the buffer after I evaluate
      (add-hook 'org-babel-after-execute-hook 'org-display-inline-images 'append)

      (add-hook 'org-mode-hook 'auto-fill-mode)

      ;; Link to manpages from org
      (org-add-link-type "man" 'org-man-open)
      (add-hook 'org-store-link-functions 'org-man-store-link)

      (defcustom org-man-command 'man
        "The Emacs command to be used to display a man page."
        :group 'org-link
        :type '(choice (const man) (const woman)))

      (defun org-man-open (path)
        "Visit the manpage on PATH.
  PATH should be a topic that can be thrown at the man command."
        (funcall org-man-command path))

      (defun org-man-store-link ()
        "Store a link to a manpage."
        (when (memq major-mode '(Man-mode woman-mode))
          ;; This is a man page, we do make this link
          (let* ((page (org-man-get-page-name))
                 (link (concat "man:" page))
                 (description (format "Manpage for %s" page)))
            (org-store-link-props
             :type "man"
             :link link
             :description description))))

      (defun org-man-get-page-name ()
        "Extract the page name from the buffer name."
        ;; This works for both `Man-mode' and `woman-mode'.
        (if (string-match " \\(\\S-+\\)\\*" (buffer-name))
            (match-string 1 (buffer-name))
          (error "Cannot create link to this man page")))

      (setq org-agenda-include-diary t
            org-log-reschedule 'note
            org-log-done 'time
            org-enforce-todo-dependencies t
            org-enforce-todo-checkbox-dependencies t
            org-fontify-whole-heading-line t
            org-fontify-done-headline t
            org-fontify-quote-and-verse-blocks t
            org-hide-emphasis-markers t
            org-agenda-restore-windows-after-quit t
            org-src-fontify-natively t     ; syntax highlight in code blocks
            org-return-follows-link t      ; return opens links
            org-confirm-babel-evaluate nil ; stop prompting for confirmation on eval
            org-src-tab-acts-natively t    ; make TAB behave as expected in src blocks
            org-support-shift-select nil
            org-image-actual-width nil
            org-html-doctype "html5"
            org-startup-folded nil
            org-refile-targets '((nil :maxlevel . 3)
                                 ("~/sync/Notes/work.org" :maxlevel . 1)
                                 ("~/sync/Notes/personal.org" :maxlevel . 3)
                                 ("~/sync/Notes/someday.org" :maxlevel . 1)
                                 ("~/sync/Notes/tickler.org" :maxlevel . 2))
            org-outline-path-complete-in-steps nil ; Refile in a single go
            org-refile-use-outline-path 'file      ; Refile to top-level
            org-todo-keywords
            '((sequence "TODO(t)" "WAITING(w)" "|" "DONE(d)" "CANCELLED(c)")))))
#+END_SRC

** HTTP and REST
Incredibly useful stuff.
#+BEGIN_SRC emacs-lisp
  (use-package restclient)
  (use-package company-restclient)
#+END_SRC
** Python
Out-of-the-box Python support for emacs seems remarkably good, at least for my
(admittedly limited these days) purposes. In any case, I stole most of these
snippets from [[https://vxlabs.com/2018/06/08/python-language-server-with-emacs-and-lsp-mode/][this article from vxlabs]]. Please note that this requires
~python-language-server~ to be installed:

#+BEGIN_SRC sh
  cd ~/Code/python-project
  pipenv install python-language-server[all]
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package lsp-ui
    :config
    (setq lsp-ui-sideline-ignore-duplicate t)
    (add-hook 'lsp-mode-hook 'lsp-ui-mode))

  (use-package company-lsp
    :config
    (push 'company-lsp company-backends))
#+END_SRC
** SQL
Note that the following depends on ~beautify-sql~:
#+BEGIN_SRC shell :exports source
  sudo gem install anbt-sql-formatter
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defun sql-beautify-region (beg end)
    "Beautify SQL in region between beg and END."
    (interactive "r")
    (save-excursion
      (shell-command-on-region beg end "beautify-sql" nil t)))

  (defun sql-beautify-buffer ()
    "Beautify SQL in buffer."
    (interactive)
    (sql-beautify-region (point-min) (point-max)))
#+END_SRC
** Other
Compile
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "M-\\") 'compile)
  (global-set-key (kbd "C-\\") 'recompile)

  (require 'ansi-color)
  (defun colorize-compilation-buffer ()
    (toggle-read-only)
    (ansi-color-apply-on-region compilation-filter-start (point))
    (toggle-read-only))
  (add-hook 'compilation-filter-hook 'colorize-compilation-buffer)
  (setq compilation-scroll-output t)
#+END_SRC

groovy-mode For ~Jenkinsfiles:~ :/
#+BEGIN_SRC emacs-lisp
  (use-package groovy-mode
    :config
    (add-to-list 'auto-mode-alist '("Jenkinsfile\\'" . groovy-mode)))
#+END_SRC
** Docker stuff
#+BEGIN_SRC emacs-lisp
  (use-package dockerfile-mode)
#+END_SRC

* OSX-specific
If we're on MacOS, enable the menu bar (hiding it won't save any space anyway)
and the fancy transparent window titlebar.
#+BEGIN_SRC emacs-lisp
  (when (string-equal system-type "darwin")
    (progn
      (menu-bar-mode +1)
      (add-to-list 'default-frame-alist '(ns-transparent-titlebar . t))
      ;(add-to-list 'default-frame-alist '(ns-appearance . dark))
      (setq ns-use-proxy-icon  nil)
      (setq frame-title-format nil)
      (setq locate-command "mdfind")))
#+END_SRC

* Startup
#+BEGIN_SRC emacs-lisp
  (defun initial-window-setup ()
    "Initially set up split windows and buffers"
    (interactive)
    (toggle-frame-fullscreen))

  (add-hook 'after-init-hook 'initial-window-setup)
#+END_SRC

* Custom file
The custom file holds all auto-generated Emacs configs, which I use for Org-mode
quite a lot. This is so my =init.el= doesn't get littered by auto-generated stuff.
#+BEGIN_SRC emacs-lisp
  (setq custom-file "~/.emacs.d/custom.el")
  (load custom-file :noerror)
#+END_SRC
* Temp stuff
#+BEGIN_SRC emacs-lisp
  (defun has-special-buffer (window)
    "Return non-nil if WINDOW contains a buffer matching `special-display-regexps'."
    (let ((name (buffer-name(window-buffer window))))
      (some (lambda (regexp) (string-match-p regexp name)) special-display-regexps)))

  (defun display-special-buffer (buf list-of-what)
    "put the special buffers in the right spot (top-left)"
    (let ((target-window (window-at 0 0))
          (pop-up-windows t))
      (if (has-special-buffer target-window)
          (let ((second-window (window-at 0 (- (frame-height) 10))))
            (message (buffer-name (window-buffer second-window)))
            (set-window-buffer second-window (window-buffer target-window))))
      (set-window-buffer target-window buf)
      target-window))

  (setq special-display-regexps
        '("^\\*Async Shell Command\\*\\(<[0-9]+>\\)?$"
          "^\\*webpack\\*$"
          "^\\*server\\*$"
          "^\\*Completions\\*$"
          "^\\*Help\\*$"
          "^\\*grep\\*$"
          "^\\*Apropos\\*$"
          "^\\*elisp macroexpansion\\*$"
          "^\\*local variables\\*$"
          "^\\*Compile-Log\\*$"
          "^\\*Quail Completions\\*$"
          "^\\*Occur\\*$"
          "^\\*frequencies\\*$"
          "^\\*compilation\\*$"
          "^\\*Locate\\*$"
          "^\\*Colors\\*$"
          "^\\*tumme-display-image\\*$"
          "^\\*SLIME Description\\*$"
          "^\\*.* output\\*$"             ; tex compilation buffer
          "^\\*TeX Help\\*$"
          "^\\*Shell Command Output\\*$"
          "^\\*Backtrace\\*$"
          "^\\*helpful .*\\*$"
          "^\\*tide-.*\\*$"
          "^TODO$"))
  (setq special-display-function 'display-special-buffer)

  (global-set-key (kbd "C-x C-b") 'ibuffer)

  (global-unset-key (kbd "s-t"))
  (desktop-save-mode)
#+END_SRC

** Making new buffers and windows
#+BEGIN_SRC emacs-lisp
  (defvar gg-scratch-buffer-mode 'org-mode
    "Major mode to be used in temporary buffers.")

  (defun make-new-buffer-or-frame (arg)
    (interactive "P")
    (let ((make-frame? (and arg t)))
      (if make-frame? (make-frame-command)
        (progn
          (switch-to-buffer (generate-new-buffer "*New*"))
          (funcall gg-scratch-buffer-mode)))))

  (global-set-key (kbd "s-n") 'make-new-buffer-or-frame)
#+END_SRC
** Auto saving
#+BEGIN_SRC emacs-lisp
  (defun xah-save-all-unsaved ()
    "Save all unsaved files. no ask.
  Version 2019-11-05"
    (interactive)
    (save-some-buffers t ))

  ;; when switching out of emacs, all unsaved files will be saved
  (add-hook 'focus-out-hook 'xah-save-all-unsaved)
#+END_SRC
** Windower
cf. [[file:elisp/windower.el][windower.el]].
#+BEGIN_SRC emacs-lisp
  (require 'windower)
  (global-set-key (kbd "<M-tab>") 'windower-switch-to-last-buffer)
  (global-set-key (kbd "M-1") 'windower-toggle-single)
  (global-set-key (kbd "s-|") 'windower-toggle-split)

  (global-set-key (kbd "<s-M-left>") 'windower-move-border-left)
  (global-set-key (kbd "<s-M-down>") 'windower-move-border-below)
  (global-set-key (kbd "<s-M-up>") 'windower-move-border-above)
  (global-set-key (kbd "<s-M-right>") 'windower-move-border-right)

  (global-set-key (kbd "<s-S-left>") 'windower-swap-left)
  (global-set-key (kbd "<s-S-down>") 'windower-swap-below)
  (global-set-key (kbd "<s-S-up>") 'windower-swap-above)
  (global-set-key (kbd "<s-S-right>") 'windower-swap-right)
#+END_SRC

** Deft
#+BEGIN_SRC emacs-lisp
  (use-package deft
    :bind
    (([f3] . deft))
    :config
    (setq deft-extensions '("org" "md" "txt")
          deft-default-extension "org"
          deft-directory "~/sync/Notes"
          deft-new-file-format "%Y%m%d%H%M"))
#+END_SRC
