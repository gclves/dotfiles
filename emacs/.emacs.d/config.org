#+TITLE: GNU Emacs configuration
#+STARTUP: indent
#+LAYOUT: post
#+OPTIONS: H:5 num:nil tags:nil toc:nil timestamps:t
#+DESCRIPTION: Loading Emacs configuration using org-babel
#+TAGS: emacs

* Who am I
#+BEGIN_SRC emacs-lisp
  (setq user-full-name "Guilherme Goncalves"
        user-email-address "gsg@ggoncalves.me"
        system-time-locale "C")
#+END_SRC

* Window setup
I like to set the appearance as early as possible to avoid glitches in
the loading process. This makes for a cleaner Emacs window.

#+BEGIN_SRC emacs-lisp
  (if (fboundp 'tool-bar-mode) (tool-bar-mode -1))
  (if (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
  (global-hl-line-mode t)
  (fringe-mode 1) ; 1px fringe
  (column-number-mode)
  (blink-cursor-mode +1)
  (tooltip-mode -1)
  (menu-bar-mode -1)
  (setq inhibit-startup-message t
        initial-scratch-message ""
        mode-line-default-help-echo nil
        indicate-buffer-boundaries nil
        indicate-empty-lines nil
        cursor-in-non-selected-windows t
        highlight-nonselected-windows nil
        bidi-display-reordering nil
        blink-matching-paren nil
        help-window-select t)
#+END_SRC

This config file is used across multiple computers and different OSes, which
render fonts quite differently. This might be overkill, but I want to have a
list of options of fonts to render so we don't end up with garbage.

#+BEGIN_SRC emacs-lisp
  (defun load-font-from-options (font-list)
    "Set the default font to the first available from FONT-LIST.
  Given a list of cons cells containing font name and font size,
  call `set-default-font' on the first one that's available"
    (let ((supported-fonts (font-family-list))
          (format-font-name (lambda (font)
                              (destructuring-bind (font-name . font-size) font
                                (concat font-name "-" (number-to-string font-size))))))
      (some (lambda (font) (when (member (car font) supported-fonts)
                             (set-frame-font (funcall format-font-name font))
                             t))
            font-list)))
#+END_SRC

* Look and feel
** Other customizations
This replaces some words with their Math symbols (eg: lambda => Î»).
#+BEGIN_SRC emacs-lisp
  (global-prettify-symbols-mode 1)
#+END_SRC

Show time and status information on the modeline, so we can go fullscreen and
don't depend on the OS.
#+BEGIN_SRC emacs-lisp
  (setq display-time-default-load-average 0) ; 1-minute load average
  (setq display-time-24hr-format t)
  (display-time-mode)
  (display-battery-mode)
#+END_SRC

*** Highlight TODO entries
#+BEGIN_SRC emacs-lisp
  (use-package hl-todo
    :init (global-hl-todo-mode)
    :bind
    (:map hl-todo-mode-map
          ("C-c <up>" . hl-todo-previous)
          ("C-c <down>" . hl-todo-next)
          ("C-c T" . hl-todo-occur)))
#+END_SRC
*** Miscellaneous
#+BEGIN_SRC emacs-lisp
  ;;; Display rules at column 80
  (setq-default fill-column 80)
  (show-paren-mode +1)
  (setq async-shell-command-display-buffer nil)
#+END_SRC
*** Pretty modeline
#+BEGIN_SRC emacs-lisp
  (use-package minions :config (minions-mode 1))
#+END_SRC
** Theme
#+begin_src emacs-lisp
  (use-package parchment-theme
    :ensure t
    :config (load-theme 'parchment t))
#+end_src
** Fonts and stuff
Prettier Unicode symbols.
#+BEGIN_SRC emacs-lisp
  (when (member "Symbola" (font-family-list))
    (set-fontset-font t 'unicode "Symbola" nil 'prepend))
#+END_SRC

Control font size with the keyboard
#+BEGIN_SRC emacs-lisp
  (defun font-size-reset ()
    "Reset the text-scale to zero."
    (interactive)
    (text-scale-set 0))

  (defvar font-size--increment 0.5
    "The increment value for `font-size-increase' and `font-size-decrease'.")

  (defun font-size-increase ()
    "Increase the text-scale by `font-size--increment'."
    (interactive)
    (text-scale-increase font-size--increment))

  (defun font-size-decrease ()
    "Decrease the text-scale by `font-size--increment'."
    (interactive)
    (text-scale-decrease font-size--increment))

  (global-set-key (kbd "s-0") 'font-size-reset)
  (global-set-key (kbd "s-=") 'font-size-increase)
  (global-set-key (kbd "s--") 'font-size-decrease)
#+END_SRC
* Editing goodies
** Ain't nobody got time for typing "yes"/"no".
#+BEGIN_SRC emacs-lisp
  (defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC
** Interactively do things
#+BEGIN_SRC emacs-lisp
    (use-package rg
      :bind
      ("M-F" . rg-menu))

    (use-package smex
      :bind
      (:map global-map
            ("M-x" . smex)
            ("M-X" . smex-major-mode-commands)))

    (use-package ido-vertical-mode
      :config
      (ido-mode 1)
      (ido-vertical-mode 1)
      (setq ido-vertical-define-keys 'C-n-and-C-p-only
            ido-vertical-show-count t))

    (ido-everywhere t)
    (global-set-key (kbd "C-x C-f") 'find-file)
    (global-set-key (kbd "s-o") 'find-file)
    (global-set-key (kbd "s-b") 'ido-switch-buffer)
    (setq ido-use-filename-at-point 'guess
          ;; fuzzy matching for ido
          ido-enable-flex-matching t
          ido-create-new-buffer 'always
          ido-ignore-extensions t)

    (use-package projectile
      :bind
      (("s-&" . projectile-run-async-shell-command-in-root)
       ("s-!" . projectile-run-eshell)
       ("C-c C-e" . projectile-run-eshell)
       ("C-c C-s" . projectile-run-shell)
       ("s-p" . projectile-find-file))
      :init (projectile-mode)
      :config
      (setq projectile-completion-system 'ido)
      (define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map))

    (use-package counsel-projectile
      :bind ("C-S-f" . counsel-projectile-rg))
#+END_SRC

** Moving around
#+BEGIN_SRC emacs-lisp
  (defun another-window ()
    "Select the previous window in the current frame.  Use `other-window' with an argument -1."
    (interactive)
    (other-window -1))

  (global-set-key (kbd "C-S-w") (lambda () (interactive) (kill-buffer nil)))
  (global-set-key (kbd "s-]") 'other-window)
  (global-set-key (kbd "s-[")  'another-window)

  (global-set-key (kbd "M-4") 'split-window-below)
  (global-set-key (kbd "M-$") 'split-window-right)
  (global-set-key (kbd "M-9") 'delete-window)

  (windmove-default-keybindings 'super)
  (setq windmove-wrap-around t)

  ; no more janky scrolling
  (setq next-line-add-newlines nil
        scroll-margin 10
        scroll-step 1
        scroll-conservatively 100
        scroll-preserve-screen-position 1)

  (use-package undo-tree
    :bind
    (("C-z" . undo-tree-undo)
     ("C-S-z" . undo-tree-redo)
     ("s-z" . undo-tree-undo)
     ("s-S-z" . undo-tree-redo)
     ("s-Z" . undo-tree-redo)
     ("C-x u" . undo-tree-visualize))
    :init
    (global-undo-tree-mode)
    :config
    (setq undo-tree-visualizer-timestamps t
          undo-tree-visualizer-diff t))

  (defvar gg--scratch-buffer "*scratch*"
    "The buffer currently marked as scratch.  Used by `gg-quick-switch-to-scratch'.")

  (defvar gg--last-visited-buffer nil
    "Last visited buffer before jumping to *scratch*. Used by `gg-quick-switch-to-scratch'.")

  (defun gg-quick-switch-to-scratch ()
    "Quickly jump to the *scratch* buffer and back."
    (interactive)
    (let ((buf (current-buffer)))
      (if (string= (buffer-name buf) gg--scratch-buffer)
          (when gg--last-visited-buffer
              (progn
                (switch-to-buffer gg--last-visited-buffer)
                (setq gg--last-visited-buffer nil)))
        (progn
          (switch-to-buffer gg--scratch-buffer)
          (setq gg--last-visited-buffer buf)))))

  (defun gg-mark-buffer-as-scratch ()
    "Mark the currently visited buffer as the scratch one."
    (interactive)
    (setq gg--scratch-buffer (buffer-name (current-buffer))))

  (global-set-key (kbd "M--") 'gg-quick-switch-to-scratch)

  (defun edit-config-file ()
    "Edit the Emacs configuration file."
    (interactive)
    (find-file "~/.emacs.d/config.org"))

  (defvar gg-todo-file (expand-file-name "~/TODO.org")
    "Location of my TODO file.")

  (defun gg-todo ()
    "Open my personal TODO file."
    (interactive)
    (find-file gg-todo-file))
  (global-set-key (kbd "<f4>") 'gg-todo)

  (defun reload-emacs-config ()
    "Reload the Emacs configuration"
    (interactive)
    (load user-init-file))

  (defun back-to-indentation-or-beginning ()
    "Move point to beginning of line, or to first non-space character"
    (interactive)
    (if (= (point) (progn (back-to-indentation) (point)))
        (beginning-of-line)))

  (global-set-key (kbd "<home>") 'back-to-indentation-or-beginning)
  (global-set-key (kbd "C-a") 'back-to-indentation-or-beginning)

  (defun goto-line-with-feedback ()
    "Show line numbers temporarily, while prompting for the line number input"
    (interactive)
    (unwind-protect
        (progn
          (display-line-numbers-mode 1)
          (goto-line (read-number "Goto line: ")))
      (display-line-numbers-mode -1)))
  (global-set-key [remap goto-line] 'goto-line-with-feedback)

  (use-package avy
    :bind
    (("s-j" . avy-goto-char-timer))
    :config
    (define-key isearch-mode-map (kbd "s-j") 'avy-isearch))
#+END_SRC

** Get rid of useless whitespace
#+BEGIN_SRC emacs-lisp
  (use-package ws-butler
    :config (ws-butler-global-mode))

  (defun cleanup-buffer-safe ()
    "Perform a bunch of safe operations on the whitespace content.
  For a more agressive cleanup that also does indentation, use
  cleanup-buffer."
    (interactive)
    (untabify (point-min) (point-max))
    (set-buffer-file-coding-system 'utf-8))

  (defun cleanup-buffer ()
    "Perform a bunch of operations on the whitespace content of a buffer.
  Including indent-buffer, which should not be called automatically on save."
    (interactive)
    (whitespace-cleanup)
    (cleanup-buffer-safe)
    (indent-region (point-min) (point-max)))

  (global-set-key (kbd "C-c N") 'cleanup-buffer)
  (global-set-key (kbd "C-c n") 'cleanup-buffer-safe)

  (global-set-key (kbd "RET") 'newline-and-indent)

  (setq fill-column 80)
  (setq-default indent-tabs-mode nil)

  ;; Render all whitespace: useful, but crowded
  ;; (setq whitespace-style '(face trailing tabs newline tab-mark space-mark))
  (setq whitespace-style '(face trailing tabs newline))
  (setq whitespace-display-mappings
        '((tab-mark 9 [8594 9])
          (space-mark 32 [183] [46])
          (space-mark 160 [164])
          (newline-mark 10 [8617 10])))

  (add-hook 'prog-mode-hook 'whitespace-mode)
#+END_SRC

** Copy-paste goodness stolen from Xah Lee
#+BEGIN_SRC emacs-lisp
  (defun xah-cut-line-or-region ()
    "Cut current line, or text selection.
  When `universal-argument' is called first, cut whole buffer (respects `narrow-to-region')."
    (interactive)
    (if current-prefix-arg
        (progn ; not using kill-region because we don't want to include previous kill
          (kill-new (buffer-string))
          (delete-region (point-min) (point-max)))
      (progn (if (use-region-p)
                 (kill-region (region-beginning) (region-end) t)
               (kill-whole-line)))))

  (defun xah-copy-line-or-region ()
    "Copy current line, or text selection.
  When called repeatedly, append copy subsequent lines.
  When `universal-argument' is called first, copy whole buffer (respects `narrow-to-region')."
    (interactive)
    (let (-p1 -p2)
      (if current-prefix-arg
          (setq -p1 (point-min) -p2 (point-max))
        (if (use-region-p)
            (setq -p1 (region-beginning) -p2 (region-end))
          (setq -p1 (line-beginning-position) -p2 (line-end-position))))
      (if (eq last-command this-command)
          (progn
            (progn ; hack. exit if there's no more next line
              (end-of-line)
              (forward-char)
              (backward-char))
            (push-mark (point) "NOMSG" "ACTIVATE")
            (kill-append "\n" nil)
            (kill-append (buffer-substring-no-properties (line-beginning-position) (line-end-position)) nil)
            (message "Line copy appended"))
        (progn
          (kill-ring-save -p1 -p2)
          (if current-prefix-arg
              (message "Buffer text copied")
            (message "Text copied"))))
      (end-of-line)
      (forward-char)))

  (global-set-key (kbd "C-x C-k") 'xah-cut-line-or-region)
  (global-set-key (kbd "s-x") 'xah-cut-line-or-region)
  (global-set-key (kbd "M-w") 'xah-copy-line-or-region)
  (global-set-key (kbd "s-c") 'xah-copy-line-or-region)
#+END_SRC

** Manipulate a file directly from its buffer
#+BEGIN_SRC emacs-lisp
  (defun delete-current-buffer-file ()
    "Removes file connected to current buffer and kills buffer."
    (interactive)
    (let ((filename (buffer-file-name))
          (buffer (current-buffer))
          (name (buffer-name)))
      (if (not (and filename (file-exists-p filename)))
          (ido-kill-buffer)
        (when (yes-or-no-p "Are you sure you want to remove this file? ")
          (delete-file filename)
          (kill-buffer buffer)
          (message "File '%s' successfully removed" filename)))))
  (global-set-key (kbd "C-x C-k") 'delete-current-buffer-file)

  (defun rename-current-buffer-file ()
    "Renames current buffer and file it is visiting."
    (interactive)
    (let ((name (buffer-name))
          (filename (buffer-file-name)))
      (if (not (and filename (file-exists-p filename)))
          (error "Buffer '%s' is not visiting a file!" name)
        (let ((new-name (read-file-name "New name: " filename)))
          (if (get-buffer new-name)
              (error "A buffer named '%s' already exists!" new-name)
            (rename-file filename new-name 1)
            (rename-buffer new-name)
            (set-visited-file-name new-name)
            (set-buffer-modified-p nil)
            (message "File '%s' successfully renamed to '%s'"
                     name (file-name-nondirectory new-name)))))))
  (global-set-key (kbd "C-x C-r") 'rename-current-buffer-file)

#+END_SRC

** Open line
#+BEGIN_SRC emacs-lisp
  (defun open-line-below ()
    (interactive)
    (end-of-line)
    (newline)
    (indent-for-tab-command))

  (defun open-line-above ()
    (interactive)
    (beginning-of-line)
    (newline)
    (forward-line -1)
    (indent-for-tab-command))

  (global-set-key (kbd "<S-return>") 'open-line-below)
  (global-set-key (kbd "<C-S-return>") 'open-line-above)
  (global-set-key (kbd "M-j") (lambda () (interactive) (join-line -1)))
  (global-set-key [f7] 'call-last-kbd-macro)
#+END_SRC
** Paredit
#+BEGIN_SRC emacs-lisp
  (use-package paredit
    :config
    (progn
      (define-key paredit-mode-map (kbd "C-j") nil)
      (define-key paredit-mode-map (kbd "RET") 'paredit-newline)
      (define-key lisp-interaction-mode-map (kbd "C-j") 'eval-print-last-sexp)

      (cl-loop for hook in '(emacs-lisp-mode-hook
                             eval-expression-minibuffer-setup-hook
                             ielm-mode-hook lisp-mode-hook
                             lisp-interaction-mode-hook
                             scheme-mode-hook)
               do (add-hook hook #'enable-paredit-mode))))
#+END_SRC

** Autocomplete and snippets
#+BEGIN_SRC emacs-lisp
  (use-package company
    :config
    (progn
      (global-company-mode)
      (setq company-tooltip-align-annotations t
            company-show-numbers t
            company-idle-delay .1
            company-tooltip-idle-delay .1)
      (add-to-list 'completion-styles 'initials t)))

  (use-package company-quickhelp
    :config
    (add-hook 'company-mode-hook 'company-quickhelp-mode))

  (use-package yasnippet
    :config
    (yas-global-mode)
    (add-hook 'prog-mode-hook 'yas-minor-mode))

  (setq-default abbrev-mode t)
  (setq save-abbrevs 'silently)
#+END_SRC

** Flycheck + Flymake
All the cool kids seem to be using it.
#+BEGIN_SRC emacs-lisp
  (use-package flycheck)
#+END_SRC

Emacs 26.1 introduced a completely redesigned Flymake mode, which I'm testing now!
#+BEGIN_SRC emacs-lisp
  (add-hook 'prog-mode-hook 'flymake-mode)
#+END_SRC
** Misc editing facilities
I got most of these from the excellent [[http://emacsrocks.com/][Emacs Rocks]].

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C--") 'bury-buffer)
  (global-set-key (kbd "C-;") 'comment-line)
  (electric-pair-mode)
  (add-hook 'prog-mode-hook 'subword-mode)

  (use-package expand-region
    :config (pending-delete-mode t)
    :bind
    (("C-=" . er/expand-region)))

  (use-package multiple-cursors
    :bind
    (("C-S-l" . mc/edit-lines)
     ("C->" . mc/mark-next-like-this)
     ("C-<" . mc/mark-previous-like-this)))

  (defun move-line-down ()
    (interactive)
    (let ((col (current-column)))
      (save-excursion
        (forward-line)
        (transpose-lines 1))
      (forward-line)
      (move-to-column col)))

  (defun move-line-up ()
    (interactive)
    (let ((col (current-column)))
      (save-excursion
        (forward-line)
        (transpose-lines -1))
      (forward-line -2)
      (move-to-column col)))

  (global-set-key (kbd "<M-S-up>") 'move-line-up)
  (global-set-key (kbd "<M-S-down>") 'move-line-down)

  ;; Replace upcase/downcase word with their dwim counterparts
  (global-set-key (kbd "M-u") 'upcase-dwim)
  (global-set-key (kbd "M-l") 'downcase-dwim)
  (global-set-key (kbd "C-x C-u") 'upcase-initials-region)
  (global-set-key (kbd "C-x C-l") nil)

  (global-set-key (kbd "s-r") 'rename-buffer)
#+END_SRC

I run many async commands, and not once have I found the confirmation
"A command is running in the default buffer.  Use a new buffer?" useful.

#+BEGIN_SRC emacs-lisp
  (setq async-shell-command-buffer 'rename-buffer)
#+END_SRC

Unbelievably useful for SQL queries and arrays in code.
#+BEGIN_SRC emacs-lisp
  (defun arrayify (start end quote)
    "Turn strings on newlines into a QUOTEd, comma-separated one-liner."
    (interactive "r\nMQuote: ")
    (let ((insertion
           (mapconcat
            (lambda (x) (format "%s%s%s" quote x quote))
            (split-string (buffer-substring start end)) ", ")))
      (delete-region start end)
      (insert insertion)))
#+END_SRC

*** Silliness
#+BEGIN_SRC emacs-lisp
  ;;; Super important!!
  (defun shrug ()
    "Insert Â¯\\_(ã)_/Â¯ at point"
    (interactive)
    (insert "Â¯\\_(ã)_/Â¯"))
  (defun lenny ()
    "Insert ( Í¡Â° ÍÊ Í¡Â°) at point"
    (interactive)
    (insert "( Í¡Â° ÍÊ Í¡Â°)"))
#+END_SRC
** Remapping out-of-reach commands
#+BEGIN_SRC emacs-lisp
  ; mapping <escape> to 'keyboard-escape-quit doesn't seem to work for some reason, so we just translate
  (define-key key-translation-map (kbd "<escape>") (kbd "C-g"))
  (global-set-key (kbd "s-u") 'revert-buffer)
#+END_SRC

** Getting help
~which-key~ is useful for discovering keybindings I'm not yet used to.
#+BEGIN_SRC emacs-lisp
  (use-package which-key :ensure t
    :config (which-key-mode))
#+END_SRC

~Helpful~ is a better help.
#+BEGIN_SRC emacs-lisp
  (use-package helpful
    :bind
    (("C-h f" . helpful-callable)
     ("C-h v" . helpful-variable)
     ("C-h k" . helpful-key)
     ("C-x C-d" . helpful-at-point)))
#+END_SRC
** Visual search
#+BEGIN_SRC emacs-lisp
  (use-package visual-regexp
    :bind
    (("C-M-%" . vr/replace)))
#+END_SRC
* Backup
#+BEGIN_SRC emacs-lisp
  (defvar --backup-directory (concat user-emacs-directory "backups"))
  (if (not (file-exists-p --backup-directory))
      (make-directory --backup-directory t))

  (setq make-backup-files t               ; back up a file the first time it is saved
        backup-by-copying t               ; don't clobber symlinks
        version-control t                 ; version numbers for backup files
        delete-old-versions t             ; delete excess backup files silently
        delete-by-moving-to-trash t
        trash-directory (expand-file-name "~/.Trash")
        kept-old-versions 6               ; oldest versions to keep when a new numbered backup is made (default: 2)
        kept-new-versions 9               ; newest versions to keep when a new numbered backup is made (default: 2)
        auto-save-default nil             ; don't auto-save every buffer that visits a file
        auto-save-timeout 20              ; number of seconds idle time before auto-save (default: 30)
        auto-save-interval 200            ; number of keystrokes between auto-saves (default: 300)

        backup-directory-alist `((".*" . ,(expand-file-name --backup-directory)))
        auto-save-file-name-transforms `((".*" ,temporary-file-directory t))

        create-lockfiles nil)

  (global-auto-revert-mode)               ; revert a fileâs buffer automatically when itâs been changed on disk
#+END_SRC

* Mode-specific
** Web
#+BEGIN_SRC emacs-lisp
  (use-package emmet-mode
    :config
    (progn
      (add-hook 'web-mode-hook 'emmet-mode)
      (add-hook 'sgml-mode-hook 'emmet-mode)
      (add-hook 'css-mode-hook emmet-mode)
      (setq emmet-self-closing-tag-style ""
            emmet-indentation 2
            css-mode-indent-offset 2))
    (define-key emmet-mode-keymap (kbd "<C-return>") nil))

  (use-package web-mode
    :mode ("\\.html\\'" "\\.tsx\\'" "\\.jsx\\'" "\\.php\\'" "\\.css\\'" "\\.tpl\\'" "\\.less\\'")
    :bind
    (:map web-mode-map
          ("C-M-u" . web-mode-element-parent)
          ("C-M-d" . web-mode-element-child)
          ("C-M-n" . web-mode-element-next)
          ("C-M-p" . web-mode-element-previous))
    :config
    (setq-default web-mode-css-indent-offset 2
                  web-mode-code-indent-offset 2
                  web-mode-markup-indent-offset 2
                  web-mode-attr-indent-offset nil
                  css-indent-offset 2)
    ;; the docs say these have to be defined in a hook
    (add-hook 'web-mode-hook (lambda ()
                               (setq web-mode-enable-css-colorization t
                                     web-mode-enable-current-element-highlight t
                                     web-mode-code-indent-offset 2
                                     js-indent-level 2
                                     web-mode-auto-close-style 1
                                     web-mode-enable-auto-indentation t
                                     web-mode-enable-auto-opening t
                                     web-mode-enable-auto-pairing t
                                     web-mode-enable-auto-quoting t
                                     web-mode-attr-indent-offset nil
                                     web-mode-attr-indent-offset nil)

                               (when (string-equal "tsx" (file-name-extension buffer-file-name))
                                 (setup-tide-mode))

                               (when (string-equal "jsx" (file-name-extension buffer-file-name))
                                 (js2-mode +1))))
    (flycheck-add-mode 'typescript-tslint 'web-mode)
    (flycheck-add-mode 'typescript-tslint 'tide-mode)
    (setq web-mode-ac-sources-alist
          '(("css" . (ac-source-css-property))
            ("html" . (ac-source-words-in-buffer ac-source-abbrev)))))
#+END_SRC
** Dired
Note that you'll need to call ~all-the-icons-install-fonts~ if you don't have the
required fonts installed (likely).

#+BEGIN_SRC emacs-lisp
  (use-package all-the-icons-dired
    :config
    (add-hook 'dired-mode-hook 'all-the-icons-dired-mode))

  (add-hook 'dired-mode-hook 'dired-hide-details-mode)
  (setq dired-dwim-target t)              ; move/copy files across dired buffers
#+END_SRC

** Org
First off, to export to HTML, we need ~htmlize~.
#+BEGIN_SRC emacs-lisp
  (use-package htmlize)
#+END_SRC

Now, we begin configuring ~org~.
#+BEGIN_SRC emacs-lisp
  (use-package org
    :bind
    (:map org-mode-map
          ("M-[" . org-set-tags)
          ("C-c s" . org-sort)
          ("<C-up>" . org-up-element)
          ("<C-down>" . org-down-element)
          ("s-t" . org-todo))
    :config
    (progn
      ;; For some reason, declaring these in `:bind` won't work
      ;; XXX these commands are global and shouldn't really be under C-c therefore
      (global-set-key (kbd "C-c l") 'org-store-link)
      (global-set-key (kbd "C-c b") 'org-switchb)
      (global-set-key (kbd "C-c j") 'org-clock-goto)
      (global-set-key (kbd "<f2>") 'org-capture)
      (global-set-key (kbd "<f3>") 'org-agenda)
      (global-set-key (kbd "C-c c") 'org-capture)
      (global-set-key (kbd "C-c a") 'org-agenda)

      (define-key org-mode-map (kbd "M-s-i") 'org-clock-in)
      (define-key org-mode-map (kbd "M-s-o") 'org-clock-out)

      ;; run shell commands from org-babel
      (defvar -org-babel-langs '((shell . t) (python . t) (ruby . t)))
      (setq org-babel-python-command "python3")
      (org-babel-do-load-languages 'org-babel-load-languages -org-babel-langs)

      ;; display/update images in the buffer after I evaluate
      (add-hook 'org-babel-after-execute-hook 'org-display-inline-images 'append)

      ;; Link to manpages from org
      (org-add-link-type "man" 'org-man-open)
      (add-hook 'org-store-link-functions 'org-man-store-link)

      (defcustom org-man-command 'man
        "The Emacs command to be used to display a man page."
        :group 'org-link
        :type '(choice (const man) (const woman)))

      (defun org-man-open (path)
        "Visit the manpage on PATH.
  PATH should be a topic that can be thrown at the man command."
        (funcall org-man-command path))

      (defun org-man-store-link ()
        "Store a link to a manpage."
        (when (memq major-mode '(Man-mode woman-mode))
          ;; This is a man page, we do make this link
          (let* ((page (org-man-get-page-name))
                 (link (concat "man:" page))
                 (description (format "Manpage for %s" page)))
            (org-store-link-props
             :type "man"
             :link link
             :description description))))

      (defun org-man-get-page-name ()
        "Extract the page name from the buffer name."
        ;; This works for both `Man-mode' and `woman-mode'.
        (if (string-match " \\(\\S-+\\)\\*" (buffer-name))
            (match-string 1 (buffer-name))
          (error "Cannot create link to this man page")))

      (setq org-agenda-include-diary t
            org-log-reschedule 'note
            org-log-done 'time
            org-enforce-todo-dependencies t
            org-enforce-todo-checkbox-dependencies t
            org-fontify-whole-heading-line t
            org-fontify-done-headline t
            org-fontify-quote-and-verse-blocks t
            org-hide-emphasis-markers t
            org-agenda-restore-windows-after-quit t
            org-src-fontify-natively t     ; syntax highlight in code blocks
            org-return-follows-link t      ; return opens links
            org-confirm-babel-evaluate nil ; stop prompting for confirmation on eval
            org-src-tab-acts-natively t    ; make TAB behave as expected in src blocks
            org-support-shift-select nil
            org-image-actual-width nil
            org-html-doctype "html5"
            org-startup-folded nil
            org-refile-targets '((nil :maxlevel . 3)
                                 ("~/sync/Notes/work.org" :maxlevel . 1)
                                 ("~/sync/Notes/personal.org" :maxlevel . 3)
                                 ("~/sync/Notes/someday.org" :maxlevel . 1)
                                 ("~/sync/Notes/tickler.org" :maxlevel . 2))
            org-outline-path-complete-in-steps nil ; Refile in a single go
            org-refile-use-outline-path 'file      ; Refile to top-level
            org-todo-keywords
            '((sequence "TODO(t)" "WAITING(w)" "|" "DONE(d)" "CANCELLED(c)")))))

  (setq org-highlight-latex-and-related '(latex script))
#+END_SRC

** HTTP and REST
Incredibly useful stuff.
#+BEGIN_SRC emacs-lisp
  (use-package restclient)
#+END_SRC

** Other
Compile
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "M-\\") 'compile)
  (global-set-key (kbd "C-\\") 'recompile)

  (require 'ansi-color)
  (defun colorize-compilation-buffer ()
    (toggle-read-only)
    (ansi-color-apply-on-region compilation-filter-start (point))
    (toggle-read-only))
  (add-hook 'compilation-filter-hook 'colorize-compilation-buffer)
  (setq compilation-scroll-output t)
#+END_SRC

* OSX-specific
If we're on MacOS, enable the menu bar (hiding it won't save any space anyway)
and the fancy transparent window titlebar.
#+BEGIN_SRC emacs-lisp
  (when (string-equal system-type "darwin")
    (require 'gg-osx-config))
#+END_SRC

* Custom file
The custom file holds all auto-generated Emacs configs, which I use for Org-mode
quite a lot. This is so my =init.el= doesn't get littered by auto-generated stuff.
#+BEGIN_SRC emacs-lisp
  (setq custom-file "~/.emacs.d/custom.el")
  (load custom-file :noerror)
#+END_SRC
* Temp stuff
#+BEGIN_SRC emacs-lisp
  (defun has-special-buffer (window)
    "Return non-nil if WINDOW contains a buffer matching `special-display-regexps'."
    (let ((name (buffer-name(window-buffer window))))
      (some (lambda (regexp) (string-match-p regexp name)) special-display-regexps)))

  (defun display-special-buffer (buf list-of-what)
    "put the special buffers in the right spot (top-left)"
    (let ((target-window (window-at 0 0))
          (pop-up-windows t))
      (if (has-special-buffer target-window)
          (let ((second-window (window-at 0 (- (frame-height) 10))))
            (message (buffer-name (window-buffer second-window)))
            (set-window-buffer second-window (window-buffer target-window))))
      (set-window-buffer target-window buf)
      target-window))

  (setq special-display-regexps
        '("^\\*Async Shell Command\\*\\(<[0-9]+>\\)?$"
          "^\\*webpack\\*$"
          "^\\*server\\*$"
          "^\\*Completions\\*$"
          "^\\*Help\\*$"
          "^\\*grep\\*$"
          "^\\*Apropos\\*$"
          "^\\*elisp macroexpansion\\*$"
          "^\\*local variables\\*$"
          "^\\*Compile-Log\\*$"
          "^\\*Quail Completions\\*$"
          "^\\*Occur\\*$"
          "^\\*frequencies\\*$"
          "^\\*compilation\\*$"
          "^\\*Locate\\*$"
          "^\\*Colors\\*$"
          "^\\*tumme-display-image\\*$"
          "^\\*SLIME Description\\*$"
          "^\\*.* output\\*$"             ; tex compilation buffer
          "^\\*TeX Help\\*$"
          "^\\*Shell Command Output\\*$"
          "^\\*Backtrace\\*$"
          "^\\*helpful .*\\*$"
          "^\\*tide-.*\\*$"
          "^TODO$"))
  (setq special-display-function 'display-special-buffer)

  (global-set-key (kbd "C-x C-b") 'ibuffer)

  (global-unset-key (kbd "s-t"))
#+END_SRC

** Making new buffers and windows
#+BEGIN_SRC emacs-lisp
  (defvar gg-scratch-buffer-mode 'org-mode
    "Major mode to be used in temporary buffers.")

  (defun make-new-buffer-or-frame (arg)
    (interactive "P")
    (let ((make-frame? (and arg t)))
      (if make-frame? (make-frame-command)
        (progn
          (switch-to-buffer (generate-new-buffer "*New*"))
          (funcall gg-scratch-buffer-mode)))))

  (global-set-key (kbd "s-n") 'make-new-buffer-or-frame)
#+END_SRC
** Auto saving
#+BEGIN_SRC emacs-lisp
  (defun xah-save-all-unsaved ()
    "Save all unsaved files. no ask.
  Version 2019-11-05"
    (interactive)
    (save-some-buffers t ))

  ;; when switching out of emacs, all unsaved files will be saved
  (add-hook 'focus-out-hook 'xah-save-all-unsaved)
#+END_SRC
** Windower
cf. [[file:elisp/windower.el][windower.el]].
#+BEGIN_SRC emacs-lisp
  (require 'windower)
  (global-set-key (kbd "<M-tab>") 'windower-switch-to-last-buffer)
  (global-set-key (kbd "M-1") 'windower-toggle-single)
  (global-set-key (kbd "s-|") 'windower-toggle-split)

  (global-set-key (kbd "<s-M-left>") 'windower-move-border-left)
  (global-set-key (kbd "<s-M-down>") 'windower-move-border-below)
  (global-set-key (kbd "<s-M-up>") 'windower-move-border-above)
  (global-set-key (kbd "<s-M-right>") 'windower-move-border-right)

  (global-set-key (kbd "<s-S-left>") 'windower-swap-left)
  (global-set-key (kbd "<s-S-down>") 'windower-swap-below)
  (global-set-key (kbd "<s-S-up>") 'windower-swap-above)
  (global-set-key (kbd "<s-S-right>") 'windower-swap-right)
#+END_SRC

** Elixir
#+BEGIN_SRC emacs-lisp
(use-package elixir-mode)
#+END_SRC
** ESS (R language)
#+begin_src emacs-lisp
  (use-package ess
    :config
    (setq ess-indent-offset 2))
#+end_src
** Shell
#+begin_src emacs-lisp
(setq explicit-shell-file-name "/bin/zsh")
#+end_src

** Terraform
#+begin_src emacs-lisp
  (use-package terraform-mode)
  (use-package terraform-doc)
#+end_src
